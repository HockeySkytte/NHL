{% extends 'base.html' %}

{% block extra_filters %}
<label>Player
  <select id="playerSelect"></select>
</label>
<label id="cardSeasonStateWrap">Season State
  <select id="cardSeasonState">
    <option value="regular" selected>Regular</option>
    <option value="playoffs">Playoffs</option>
    <option value="all">All</option>
  </select>
</label>
<label id="cardStrengthStateWrap">Strength State
  <select id="cardStrengthState">
    <option value="5v5" selected>5v5</option>
    <option value="PP">PP</option>
    <option value="SH">SH</option>
    <option value="Other">Other</option>
    <option value="all">All</option>
  </select>
</label>
<label id="cardRatesWrap">Totals / Rates
  <select id="cardRates">
    <option value="Totals" selected>Totals</option>
    <option value="Per60">Per 60</option>
    <option value="PerGame">Per Game</option>
  </select>
</label>
<label id="cardXgModelWrap">xG Model
  <select id="cardXgModel">
    <option value="xG_S">xG_S (Shots)</option>
    <option value="xG_F" selected>xG_F (Fenwick)</option>
    <option value="xG_F2">xG_F2 (Fenwick)</option>
  </select>
</label>
<label id="cardMinGpWrap">Min GP
  <input id="cardMinGp" type="number" min="0" step="1" placeholder="0" />
</label>
<label id="cardMinToiWrap">Min TOI
  <input id="cardMinToi" type="number" min="0" step="1" placeholder="0" />
</label>
<label id="cardScopeWrap">Scope
  <div id="cardScopeButtons" class="segmented" role="group" aria-label="Card scope">
    <button type="button" class="seg-btn active" data-scope="season">Season</button>
    <button type="button" class="seg-btn" data-scope="career">Career</button>
  </div>
  <input id="cardScope" type="hidden" value="season" />
</label>
{% endblock %}

{% block head %}
<style>
  .skater-wrap{ width:100%; margin-left:-10px; }
  .skater-card{ width:100%; box-sizing:border-box; background:rgba(255,255,255,0.02); border:1px solid #232a3a; border-radius:14px; padding:24px 26px 18px; }
  .skater-top{ display:flex; gap:22px; align-items:center; }
  .skater-img{ width:170px; height:170px; border-radius:18px; object-fit:cover; background:var(--panel); border:1px solid #2a3142; }
  .skater-name{ font-size:38px; font-weight:800; margin:0; letter-spacing:.2px; }
  .skater-sub{ margin-top:10px; color:var(--text-dim); font-size:16px; display:flex; gap:18px; flex-wrap:wrap; }
  .kv{ display:flex; gap:6px; align-items:baseline; }
  .k{ text-transform:uppercase; font-size:12px; letter-spacing:1px; color:var(--text-dim); font-weight:750; }
  .v{ font-weight:750; color:var(--text); }
  .skater-empty{ text-align:center; color:var(--text-dim); padding:30px 10px; }
  .err{ color:#ff8f8f; font-weight:650; }

  #cardMinGpWrap input, #cardMinToiWrap input{ width:94px; }

  .segmented{ display:flex; gap:8px; margin-top:6px; }
  .seg-btn{ flex:1; background:transparent; border:1px solid #2a3142; color:var(--text); padding:8px 10px; border-radius:10px; font-weight:750; letter-spacing:.2px; cursor:pointer; }
  .seg-btn.active{ outline:2px solid var(--accent); background:rgba(255,255,255,0.03); }

  .subtabs{ display:flex; gap:12px; align-items:center; margin-top:18px; }
  .subtab-btn{ background:transparent; border:1px solid #2a3142; color:var(--text); padding:8px 14px; border-radius:10px; font-weight:750; letter-spacing:.2px; cursor:pointer; }
  .subtab-btn.active{ outline:2px solid var(--accent); }
  .panel{ margin-top:14px; box-sizing:border-box; background:rgba(255,255,255,0.02); border:1px solid #232a3a; border-radius:14px; padding:16px 16px 12px; }
  .mini-table{ width:100%; border-collapse:collapse; font-size:14px; }
  .mini-table th{ text-align:left; font-size:12px; text-transform:uppercase; letter-spacing:.8px; padding:10px 8px; color:var(--text-dim); font-weight:800; border-bottom:1px solid #222b37; }
  .mini-table td{ padding:10px 8px; border-bottom:1px solid #1a2230; }

  #tabPanelCard.panel{ padding:10px 10px 8px; }
  .card-panel-hd{ display:flex; align-items:center; justify-content:space-between; gap:12px; padding:2px 2px 10px; }
  .card-panel-meta{ color:rgba(255,255,255,0.95); font-size:18px; font-style:italic; font-weight:800; letter-spacing:.2px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .card-grid{ display:grid; grid-template-columns: 1fr 1fr 1fr; gap:36px; width:100%; margin:0; }
  @media (max-width: 980px){ .card-grid{ grid-template-columns: 1fr; } }
  .card-col{ border:none; border-radius:0; padding:0; background:transparent; }
  .card-col h3{ margin:0 0 10px; font-size:18px; letter-spacing:.6px; text-transform:uppercase; color:rgba(255,255,255,0.98); font-weight:850; }
  .metric{ padding:2px 0 10px; border:none; border-radius:0; background:transparent; margin-bottom:10px; }
  .metric:last-child{ margin-bottom:0; }
  .metric-head{ display:flex; align-items:baseline; justify-content:space-between; gap:10px; }
  .metric-name{ font-size:12px; letter-spacing:.2px; text-transform:none; color:var(--text-dim); font-weight:850; }
  .metric-val{ font-variant-numeric: tabular-nums; font-weight:850; color:rgba(255,255,255,0.95); }
  .metric-bar{ position:relative; height:10px; border-radius:999px; background:transparent; border:1px solid rgba(255,255,255,0.16); overflow:hidden; margin-top:8px; }
  .metric-fill{ position:absolute; top:0; left:0; height:100%; border-radius:999px; width:0%; background:#f7f7f7; }

  .card-slot{ margin-bottom:14px; }
  .card-slot:last-child{ margin-bottom:0; }

  .config-btn{ background:var(--panel-alt); border:1px solid #2a3142; color:var(--value-text, var(--text)); padding:8px 12px; border-radius:10px; font-weight:750; cursor:pointer; font-size:13px; }
  .config-btn:hover{ background:rgba(255,255,255,0.05); }

  .modal{ position:fixed; inset:0; background:rgba(0,0,0,0.55); display:flex; align-items:center; justify-content:center; z-index:2000; }
  .modal[hidden]{ display:none !important; }
  .modal-card{ width:min(1100px, calc(100vw - 28px)); max-height:calc(100vh - 28px); overflow:auto; background:#0f1522; border:1px solid #2a3142; border-radius:14px; box-shadow:0 18px 44px rgba(0,0,0,0.6); }
  .modal-hd{ display:flex; align-items:center; justify-content:space-between; gap:12px; padding:14px 16px; border-bottom:1px solid #232a3a; }
  .modal-title{ font-weight:900; letter-spacing:.2px; }
  .modal-bd{ padding:14px 16px; }
  .cc-grid{ display:grid; grid-template-columns: repeat(3, 1fr); gap:12px; }
  @media (max-width: 980px){ .cc-grid{ grid-template-columns:1fr; } }
  .cc-slot{ border:1px solid #232a3a; border-radius:12px; padding:12px; background:rgba(255,255,255,0.02); }
  .cc-slot .s{ font-size:11px; letter-spacing:.8px; text-transform:uppercase; color:var(--text-dim); font-weight:900; }
  .cc-slot .n{ margin-top:6px; font-weight:850; }
  .cc-help{ color:var(--text-dim); font-size:13px; margin-bottom:12px; }
  .cc-row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-bottom:10px; }
  .cc-row select{ min-width:240px; }
  .cc-cat{ border-top:1px solid #232a3a; padding-top:10px; margin-top:10px; }
  .cc-cat summary{ cursor:pointer; font-weight:850; }
  .cc-metrics{ margin-top:8px; display:grid; grid-template-columns: 1fr 1fr; gap:8px 12px; }
  @media (max-width: 980px){ .cc-metrics{ grid-template-columns:1fr; } }
  .cc-metrics .cc-metric{ display:flex; flex-direction:row; gap:8px; align-items:center; font-size:13px; color:rgba(255,255,255,0.92); text-transform:none; letter-spacing:0; font-weight:650; }
  .cc-metrics .cc-metric input[type="checkbox"]{ margin:0; flex:0 0 auto; }
  .cc-metrics .cc-metric span{ display:inline; }
  .modal-ft{ display:flex; gap:10px; justify-content:flex-end; padding:12px 16px; border-top:1px solid #232a3a; }
  .btn{ background:var(--panel-alt); border:1px solid #2a3142; color:var(--value-text, var(--text)); padding:8px 12px; border-radius:10px; font-weight:750; cursor:pointer; font-size:13px; }
  .btn:hover{ background:rgba(255,255,255,0.05); }
  .btn.primary{ outline:2px solid var(--accent); }

  .rapm-controls{ display:flex; flex-wrap:wrap; gap:14px; align-items:flex-end; margin-bottom:14px; }
  .rapm-controls label{ min-width:160px; }
  .rapm-controls select{ color:var(--value-text, var(--text)); }

  .rapm-split{ display:grid; grid-template-columns: 1.4fr 0.8fr 0.8fr; gap:14px; max-width:1150px; margin:0 auto; }
  .rapm-sect{ --rapmBarH: 340px; border:1px solid #232a3a; border-radius:12px; padding:12px 12px 10px; background:rgba(255,255,255,0.01); }
  .rapm-sect h3{ margin:0 0 10px; font-size:18px; letter-spacing:.6px; text-transform:uppercase; color:rgba(255,255,255,0.98); font-weight:850; }
  .toi{ margin-top:8px; font-size:12px; color:rgba(255,255,255,0.90); text-align:center; font-weight:750; }

  .rapm-row{ display:flex; gap:3px; align-items:flex-start; justify-content:center; }
  .rapm-axis{ width:40px; height:var(--rapmBarH); position:relative; }
  .rapm-axis .lbl{ position:absolute; left:0; font-size:11px; color:var(--text-dim); }
  .rapm-axis .top{ top:0; }
  .rapm-axis .mid{ transform:translateY(-50%); }
  .rapm-axis .bot{ bottom:0; }

  .bars{ display:flex; gap:12px; align-items:flex-end; justify-content:center; flex:0; }
  .bar-col{ width:112px; }
  .bar-label{ text-align:center; font-size:12px; color:var(--text-dim); margin-top:8px; }
  .bar-value{ text-align:center; font-size:12px; font-weight:750; margin-top:6px; }
  .bar-area{ position:relative; height:var(--rapmBarH); border-radius:10px; background:rgba(255,255,255,0.02); border:1px solid #1f2734; overflow:hidden; }
  .bar-line{ position:absolute; left:0; right:0; height:1px; background:#273246; }
  .bar{ position:absolute; left:14%; width:72%; border-radius:8px; background:var(--accent); opacity:1; }
  .bar.neg{ background:#ff6a6a; opacity:1; }

  .rapm-career{ max-width:1150px; margin:0 auto; }
  .rapm-career .career-area{ width:100%; flex:1; min-width:0; }
  .rapm-career svg{ position:absolute; inset:0; width:100%; height:100%; }
  .rapm-career-legend{ display:flex; gap:22px; align-items:center; justify-content:center; margin-top:10px; color:rgba(255,255,255,0.90); font-size:14px; letter-spacing:.2px; font-weight:750; }
  .rapm-career-legend .sw{ width:12px; height:12px; border-radius:3px; display:inline-block; margin-right:8px; }
  .rapm-tooltip{ position:absolute; z-index:20; pointer-events:none; background:rgba(15,21,34,0.96); border:1px solid #2a3142; border-radius:10px; padding:10px 12px; box-shadow:0 10px 26px rgba(0,0,0,0.45); min-width:170px; display:none; }
  .rapm-tooltip .t-title{ font-weight:850; font-size:13px; color:rgba(255,255,255,0.95); margin-bottom:6px; letter-spacing:.2px; }
  .rapm-tooltip .t-row{ display:flex; align-items:center; justify-content:space-between; gap:12px; font-size:12px; color:rgba(255,255,255,0.86); }
  .rapm-tooltip .dot{ width:8px; height:8px; border-radius:50%; display:inline-block; margin-right:8px; flex:0 0 auto; }
  .rapm-tooltip .lbl{ display:flex; align-items:center; min-width:0; }
  .rapm-tooltip .val{ font-variant-numeric:tabular-nums; font-weight:800; }

  .proj-subtabs{ display:flex; gap:12px; align-items:center; margin-top:6px; }
  .proj-subtab-btn{ background:transparent; border:1px solid #2a3142; color:var(--text); padding:8px 14px; border-radius:10px; font-weight:750; letter-spacing:.2px; cursor:pointer; }
  .proj-subtab-btn.active{ outline:2px solid var(--accent); }
  .proj-subpanel{ margin-top:14px; background:rgba(0,0,0,.18); border:1px solid #232a3a; border-radius:12px; padding:16px; }
  .proj-subpanel[hidden]{ display:none !important; }
  .proj-grid{ display:grid; grid-template-columns: 320px 1fr; gap:16px; align-items:start; }
  .kpi-card{ background:rgba(0,0,0,.12); border:1px solid #2a3142; border-radius:12px; padding:12px 12px; text-align:center; }
  .kpi-title{ font-size:11px; letter-spacing:.8px; text-transform:uppercase; color:var(--text-dim); font-weight:850; }
  .kpi-value{ margin-top:6px; font-size:18px; font-weight:850; color:var(--text); font-variant-numeric: tabular-nums; }
  .kpi-list{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
  .proj-canvas{ width:100%; height:360px; }
  #projPlayerRadar{ height:500px; }
  #projTeamStack{ height:600px; }
  .proj-table-wrap{ overflow:auto; border:1px solid #232a3a; border-radius:12px; }
  .proj-export-wrap{ display:flex; justify-content:flex-end; margin-bottom:12px; }
  .proj-export-btn{ background:var(--panel-alt); border:1px solid #2a3142; color:var(--value-text, var(--text)); padding:8px 14px; border-radius:8px; font-weight:650; cursor:pointer; font-size:13px; }
  .proj-export-btn:hover{ background:rgba(255,255,255,0.05); }
  .proj-table{ width:100%; border-collapse:collapse; font-size:14px; }
  .proj-table th{ position:sticky; top:0; background:#0f1522; text-align:left; font-size:12px; text-transform:uppercase; letter-spacing:.8px; padding:10px 8px; color:var(--text-dim); font-weight:800; border-bottom:1px solid #222b37; cursor:pointer; user-select:none; }
  .proj-table td{ padding:10px 8px; border-bottom:1px solid #1a2230; white-space:nowrap; text-align:center; }
  .proj-table td.name{ text-align:left; }
  .proj-table th.name{ text-align:left; }
  .proj-table td.num, .proj-table th.num{ text-align:center; }
  .proj-table tr.selected-player{ background:var(--league-highlight-color, rgba(77,163,255,0.12)); }
  .sort-ind{ color:rgba(255,255,255,0.6); font-weight:900; margin-left:6px; }
</style>
{% endblock %}

{% block content %}
<div class="skater-wrap">
  <div class="skater-card">
    <div class="skater-top">
      <img id="skaterImg" class="skater-img" alt="Player" />
      <div style="min-width:0;">
        <h2 id="skaterName" class="skater-name">Select a player</h2>
        <div id="skaterInfo" class="skater-sub"></div>
      </div>
    </div>

    <div class="subtabs" role="tablist" aria-label="Skater tabs">
      <button id="tabCard" class="subtab-btn active" type="button" role="tab" aria-selected="true">Card</button>
      <button id="tabRAPM" class="subtab-btn" type="button" role="tab" aria-selected="false">RAPM</button>
      <button id="tabProjections" class="subtab-btn" type="button" role="tab" aria-selected="false">Projections</button>
    </div>

    <div id="tabPanelCard" class="panel" role="tabpanel">
      <div class="card-panel-hd">
        <div id="cardSlicerSummary" class="card-panel-meta"></div>
        <button id="btnConfigureCard" class="config-btn" type="button">Configure Card</button>
      </div>
      <div id="cardPanelInner" class="skater-empty">Select a player to view Card.</div>
    </div>

    <div id="tabPanelRAPM" class="panel" role="tabpanel" style="display:none;">
      <div id="rapmPanelInner" class="skater-empty">Select a player to view RAPM.</div>
    </div>
    <div id="tabPanelProjections" class="panel" role="tabpanel" style="display:none;">
      <div id="projPanelInner">
        <div class="proj-subtabs" role="tablist" aria-label="Skater projections tabs">
          <button id="projTabPlayer" class="proj-subtab-btn active" type="button" role="tab" aria-selected="true">Player</button>
          <button id="projTabTeam" class="proj-subtab-btn" type="button" role="tab" aria-selected="false">Team</button>
          <button id="projTabLeague" class="proj-subtab-btn" type="button" role="tab" aria-selected="false">League</button>
        </div>

        <section id="projPanelPlayer" class="proj-subpanel" role="tabpanel">
          <div class="proj-grid">
            <div id="projPlayerKpis" class="kpi-list"></div>
            <div style="min-width:0;">
              <canvas id="projPlayerRadar" class="proj-canvas"></canvas>
            </div>
          </div>
        </section>

        <section id="projPanelTeam" class="proj-subpanel" role="tabpanel" hidden>
          <canvas id="projTeamStack" class="proj-canvas"></canvas>
        </section>

        <section id="projPanelLeague" class="proj-subpanel" role="tabpanel" hidden>
          <div class="proj-export-wrap">
            <button id="projExportCsv" class="proj-export-btn">Export CSV</button>
          </div>
          <div class="proj-table-wrap">
            <table id="projLeagueTable" class="proj-table"></table>
          </div>
        </section>
      </div>
    </div>

    <div id="skaterMsg" class="skater-empty" style="margin-top:10px;">Choose Team, Season, and Player.</div>
  </div>
</div>

<div id="cardConfigModal" class="modal" hidden>
  <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="cardConfigTitle">
    <div class="modal-hd">
      <div id="cardConfigTitle" class="modal-title">Configure Card</div>
      <button id="btnCloseCardConfig" class="btn" type="button">Close</button>
    </div>
    <div class="modal-bd">
      <div class="cc-help">Choose a category and metrics in each slot.</div>
      <div id="ccGrid" class="cc-grid"></div>
    </div>
    <div class="modal-ft">
      <input id="ccImportFile" type="file" accept="application/json" style="display:none;" />
      <button id="btnExportCardConfig" class="btn" type="button">Export</button>
      <button id="btnImportCardConfig" class="btn" type="button">Import</button>
      <button id="btnResetCardConfig" class="btn" type="button">Reset defaults</button>
      <button id="btnSaveCardConfig" class="btn primary" type="button">Save</button>
    </div>
  </div>
</div>

<script id="teams-data" type="application/json">{{ teams|tojson|safe }}</script>
{% endblock %}

{% block scripts %}
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script>
const teamSelect = document.getElementById('teamSelect');
const seasonSelect = document.getElementById('seasonSelect');
const playerSelect = document.getElementById('playerSelect');

const skaterImg = document.getElementById('skaterImg');
const skaterName = document.getElementById('skaterName');
const skaterInfo = document.getElementById('skaterInfo');
const skaterMsg = document.getElementById('skaterMsg');

const tabCard = document.getElementById('tabCard');
const tabRAPM = document.getElementById('tabRAPM');
const tabProjections = document.getElementById('tabProjections');
const tabPanelCard = document.getElementById('tabPanelCard');
const tabPanelRAPM = document.getElementById('tabPanelRAPM');
const tabPanelProjections = document.getElementById('tabPanelProjections');
const cardPanelInner = document.getElementById('cardPanelInner');
const rapmPanelInner = document.getElementById('rapmPanelInner');
const projPanelInner = document.getElementById('projPanelInner');
const cardSlicerSummary = document.getElementById('cardSlicerSummary');

const cardScope = document.getElementById('cardScope');
const cardScopeButtons = document.getElementById('cardScopeButtons');
const cardSeasonState = document.getElementById('cardSeasonState');
const cardMinGp = document.getElementById('cardMinGp');
const cardMinToi = document.getElementById('cardMinToi');
const cardStrengthState = document.getElementById('cardStrengthState');
const cardRates = document.getElementById('cardRates');
const cardXgModel = document.getElementById('cardXgModel');

const btnConfigureCard = document.getElementById('btnConfigureCard');
const cardConfigModal = document.getElementById('cardConfigModal');
const btnCloseCardConfig = document.getElementById('btnCloseCardConfig');
const btnResetCardConfig = document.getElementById('btnResetCardConfig');
const btnSaveCardConfig = document.getElementById('btnSaveCardConfig');
const btnExportCardConfig = document.getElementById('btnExportCardConfig');
const btnImportCardConfig = document.getElementById('btnImportCardConfig');
const ccImportFile = document.getElementById('ccImportFile');
const ccGrid = document.getElementById('ccGrid');

const cardScopeWrap = document.getElementById('cardScopeWrap');
const cardSeasonStateWrap = document.getElementById('cardSeasonStateWrap');
const cardMinGpWrap = document.getElementById('cardMinGpWrap');
const cardMinToiWrap = document.getElementById('cardMinToiWrap');
const cardStrengthStateWrap = document.getElementById('cardStrengthStateWrap');
const cardRatesWrap = document.getElementById('cardRatesWrap');
const cardXgModelWrap = document.getElementById('cardXgModelWrap');

let __cardDefs = null;
let __cardConfig = null;
const CARD_CONFIG_KEY = 'nhlSkatersCardConfig_v1';
const CARD_SLOTS = ['L1','C1','R1','L2','C2','R2','L3','C3','R3'];

const projTabPlayer = document.getElementById('projTabPlayer');
const projTabTeam = document.getElementById('projTabTeam');
const projTabLeague = document.getElementById('projTabLeague');
const projPanelPlayer = document.getElementById('projPanelPlayer');
const projPanelTeam = document.getElementById('projPanelTeam');
const projPanelLeague = document.getElementById('projPanelLeague');
const projPlayerKpis = document.getElementById('projPlayerKpis');
const projLeagueTable = document.getElementById('projLeagueTable');
const projExportCsv = document.getElementById('projExportCsv');

let __projLeaguePlayers = null;
let __projRadarChart = null;
let __projTeamChart = null;
let __projLeagueSort = { key: 'total', dir: 'desc' };

let __rapmCache = null;
let __ctxCache = null;
let __rapmKey = '';
let __scaleCache = null;
let __scaleKey = '';

const teams = JSON.parse(document.getElementById('teams-data').textContent);

function setCardScope(scope){
  const s = (String(scope||'').toLowerCase() === 'career') ? 'career' : 'season';
  if(cardScope) cardScope.value = s;
  try{
    const btns = cardScopeButtons ? Array.from(cardScopeButtons.querySelectorAll('button[data-scope]')) : [];
    btns.forEach(b=>{
      const v = String(b.getAttribute('data-scope')||'').toLowerCase();
      b.classList.toggle('active', v === s);
      b.setAttribute('aria-pressed', v === s ? 'true' : 'false');
    });
  }catch(_){ /* ignore */ }
}

// Wire Scope segmented buttons.
try{
  const btns = cardScopeButtons ? Array.from(cardScopeButtons.querySelectorAll('button[data-scope]')) : [];
  btns.forEach(b=>{
    b.addEventListener('click', ()=>{
      setCardScope(b.getAttribute('data-scope'));
      loadCardPanel();
    });
  });
  setCardScope(cardScope?.value || 'season');
}catch(_){ /* ignore */ }

function seasonToStartYear(season){
  const s = String(season||'').trim();
  if(s.length >= 4) return parseInt(s.slice(0,4),10);
  return null;
}

function calcAgeOnOct1(birthDateStr, season){
  if(!birthDateStr) return null;
  const startYear = seasonToStartYear(season);
  if(!startYear) return null;
  const birth = new Date(birthDateStr + 'T00:00:00Z');
  if(isNaN(birth)) return null;
  const ref = new Date(Date.UTC(startYear, 9, 1));
  let age = ref.getUTCFullYear() - birth.getUTCFullYear();
  const m = ref.getUTCMonth() - birth.getUTCMonth();
  if(m < 0 || (m === 0 && ref.getUTCDate() < birth.getUTCDate())) age--;
  return age;
}

function inchesToFeetIn(inches){
  const n = Number(inches);
  if(!Number.isFinite(n)) return null;
  const ft = Math.floor(n/12);
  const inch = n % 12;
  return `${ft}'${inch}"`;
}

function setMsg(text, isError=false){
  if(!skaterMsg) return;
  skaterMsg.textContent = text || '';
  skaterMsg.className = 'skater-empty' + (isError ? ' err' : '');
}

function setHeadshot(team, season, playerId){
  const s = String(season||'').trim();
  const t = String(team||'').trim();
  const pid = String(playerId||'').trim();
  const primary = `https://assets.nhle.com/mugs/nhl/${s}/${t}/${pid}.png`;
  const fallback = `https://assets.nhle.com/mugs/nhl/latest/${pid}.png`;
  skaterImg.onerror = () => {
    if(skaterImg.dataset.fallbackDone === '1') return;
    skaterImg.dataset.fallbackDone = '1';
    skaterImg.src = fallback;
  };
  skaterImg.dataset.fallbackDone = '0';
  skaterImg.src = primary;
}

function renderPlayerLanding(landing){
  const first = landing?.firstName?.default || '';
  const last = landing?.lastName?.default || '';
  const full = (first + ' ' + last).trim() || 'Unknown player';
  skaterName.textContent = full;

  const season = seasonSelect?.value;
  const age = calcAgeOnOct1(landing?.birthDate, season);

  const height = inchesToFeetIn(landing?.heightInInches);
  const heightCm = landing?.heightInCentimeters;
  const weightLb = landing?.weightInPounds;
  const weightKg = landing?.weightInKilograms;

  const draft = landing?.draftDetails || {};
  const draftYear = draft?.year;
  const overallPick = draft?.overallPick;

  const parts = [];
  if(height || heightCm) parts.push({k:'Height', v: [height, heightCm?`${heightCm} cm`:null].filter(Boolean).join(' • ')});
  if(weightLb || weightKg) parts.push({k:'Weight', v: [weightLb?`${weightLb} lb`:null, weightKg?`${weightKg} kg`:null].filter(Boolean).join(' • ')});
  if(age != null) parts.push({k:'Age', v: `${age}`});
  if(draftYear) parts.push({k:'Draft', v: overallPick?`${draftYear} • #${overallPick}`:`${draftYear}`});

  skaterInfo.innerHTML = parts.map(p=>`<div class="kv"><span class="k">${p.k}</span><span class="v">${p.v}</span></div>`).join('');
}

function setActiveTab(which){
  const w = String(which || '').toLowerCase();
  const isC = (w === 'card');
  const isR = (w === 'rapm');
  const isP = (w === 'projections');
  // default
  const finalC = (isC || (!isR && !isP));
  const finalR = isR;
  const finalP = isP;

  tabCard?.classList.toggle('active', finalC);
  tabRAPM?.classList.toggle('active', finalR);
  tabProjections?.classList.toggle('active', finalP);
  if(tabCard) tabCard.setAttribute('aria-selected', finalC ? 'true' : 'false');
  if(tabRAPM) tabRAPM.setAttribute('aria-selected', finalR ? 'true' : 'false');
  if(tabProjections) tabProjections.setAttribute('aria-selected', finalP ? 'true' : 'false');
  if(tabPanelCard) tabPanelCard.style.display = finalC ? '' : 'none';
  if(tabPanelRAPM) tabPanelRAPM.style.display = finalR ? '' : 'none';
  if(tabPanelProjections) tabPanelProjections.style.display = finalP ? '' : 'none';

  setCardSlicersVisible(finalC);

  if(finalC) loadCardPanel();
  if(finalR) loadRAPMPanel();
  if(finalP && projectionsEnabled()) loadProjectionsPanel();
}

function setCardSlicersVisible(on){
  const show = !!on;
  // Configure button lives in the Card panel header; only show it on Card.
  if(btnConfigureCard) btnConfigureCard.style.display = show ? '' : 'none';
  if(cardSlicerSummary) cardSlicerSummary.style.display = show ? '' : 'none';
  if(cardScopeWrap) cardScopeWrap.style.display = show ? '' : 'none';
  if(cardSeasonStateWrap) cardSeasonStateWrap.style.display = show ? '' : 'none';
  if(cardMinGpWrap) cardMinGpWrap.style.display = show ? '' : 'none';
  if(cardMinToiWrap) cardMinToiWrap.style.display = show ? '' : 'none';
  if(cardStrengthStateWrap) cardStrengthStateWrap.style.display = show ? '' : 'none';
  if(cardRatesWrap) cardRatesWrap.style.display = show ? '' : 'none';
  if(cardXgModelWrap) cardXgModelWrap.style.display = show ? '' : 'none';
}

function updateCardSlicerSummary(){
  if(!cardSlicerSummary) return;
  const scope = String(cardScope?.value || 'season');
  const rawSeason = String(seasonSelect?.value || '').trim();
  let season = rawSeason;
  if(/^\d{8}$/.test(rawSeason)){
    season = `${rawSeason.slice(0,4)}/${rawSeason.slice(4,8)}`;
  }
  const seasonState = String(cardSeasonState?.selectedOptions?.[0]?.textContent || cardSeasonState?.value || '').trim();
  const strengthState = String(cardStrengthState?.selectedOptions?.[0]?.textContent || cardStrengthState?.value || '').trim();
  const ratesText = String(cardRates?.selectedOptions?.[0]?.textContent || cardRates?.value || '').trim();
  const minGp = Number.parseInt(String(cardMinGp?.value || '0'), 10);
  const minToi = Number(String(cardMinToi?.value || '0'));
  const minParts = [];
  if(Number.isFinite(minGp) && minGp > 0) minParts.push(`Min GP ${minGp}`);
  if(Number.isFinite(minToi) && minToi > 0) minParts.push(`Min TOI ${minToi}`);

  const first = (scope === 'career') ? 'Career' : season;
  const parts = [first, seasonState, strengthState, ratesText].concat(minParts).filter(Boolean);
  cardSlicerSummary.textContent = parts.join(' - ');
}

function projectionsEnabled(){
  return String(seasonSelect?.value || '').trim() === '20252026';
}

function cardEnabled(){
  // Card supports all seasons (20252026 from Sheets6; others from nhl_seasonstats.csv)
  return true;
}

function updateTabsVisibility(){
  const enabled = projectionsEnabled();
  if(tabProjections) tabProjections.style.display = enabled ? '' : 'none';
  const projActive = tabProjections?.classList.contains('active');
  if(!enabled && projActive) setActiveTab('card');
}

// base.html populates seasonSelect asynchronously and sets seasonSelect.value
// without dispatching a change event. In slower environments (prod), our initial
// updateTabsVisibility() can run before the value is set, hiding Projections.
// This watcher ensures the tab visibility stays in sync once the season loads.
let __seasonWatchTimer = null;
let __seasonWatchLast = null;
function __isSeasonId(v){ return /^\d{8}$/.test(String(v||'')); }
function installSeasonWatcher(){
  if(__seasonWatchTimer) return;
  __seasonWatchLast = String(seasonSelect?.value || '').trim();
  const startedAt = Date.now();
  __seasonWatchTimer = setInterval(()=>{
    const v = String(seasonSelect?.value || '').trim();
    if(v !== __seasonWatchLast && __isSeasonId(v)){
      __seasonWatchLast = v;
      updateTabsVisibility();
    }
    if(Date.now() - startedAt > 12000){
      clearInterval(__seasonWatchTimer);
      __seasonWatchTimer = null;
    }
  }, 200);
}
installSeasonWatcher();

// Default tab is Card; keep sidebar slicers in sync on initial load.
setCardSlicersVisible(true);

function safeJsonParse(s){
  try{ return JSON.parse(String(s||'')); }catch(_){ return null; }
}

async function ensureCardDefs(){
  if(__cardDefs) return __cardDefs;
  try{
    const r = await fetch('/api/skaters/card/defs', { cache:'no-store' });
    const js = await r.json();
    __cardDefs = js && typeof js === 'object' ? js : { categories:[], metrics:[] };
  }catch(_){
    __cardDefs = { categories:[], metrics:[] };
  }
  return __cardDefs;
}

function buildDefaultCardConfig(defs){
  const metrics = Array.isArray(defs?.metrics) ? defs.metrics : [];
  const categories = Array.isArray(defs?.categories) ? defs.categories : [];
  const byCat = {};
  metrics.forEach(m=>{
    const c = String(m?.category||'').trim();
    if(!c) return;
    (byCat[c] = byCat[c] || []).push(m);
  });

  const categorySelected = {};
  const categoryPlace = {};
  categories.forEach(c=>{
    const cat = String(c||'').trim();
    const ms = byCat[cat] || [];
    const defaults = ms.filter(x=>String(x?.default||'').trim() === '1' || x?.default === true || String(x?.default||'').toLowerCase()==='true');
    categorySelected[cat] = defaults.map(x=>String(x?.id||'')).filter(Boolean);
    const p = (defaults.find(x=>String(x?.place||'').trim() && String(x?.place||'').trim() !== '0') || ms.find(x=>String(x?.place||'').trim() && String(x?.place||'').trim() !== '0'));
    if(p) categoryPlace[cat] = String(p.place).trim();
  });

  const slots = {};
  CARD_SLOTS.forEach(s=>{ slots[s] = null; });
  Object.entries(categoryPlace).forEach(([cat, place])=>{
    if(CARD_SLOTS.includes(place)) slots[place] = cat;
  });
  return { version: 1, slots, categorySelected };
}

function loadCardConfig(defs){
  const raw = safeJsonParse(localStorage.getItem(CARD_CONFIG_KEY));
  if(raw && typeof raw === 'object' && raw.slots && raw.categorySelected) return raw;
  return buildDefaultCardConfig(defs);
}

function saveCardConfig(cfg){
  try{ localStorage.setItem(CARD_CONFIG_KEY, JSON.stringify(cfg)); }catch(_){ /* ignore */ }
}

function downloadTextFile(filename, text, mime='application/json'){
  try{
    const blob = new Blob([String(text||'')], { type: mime });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{
      try{ URL.revokeObjectURL(a.href); }catch(_){/*noop*/}
      try{ a.remove(); }catch(_){/*noop*/}
    }, 250);
  }catch(_){ /* ignore */ }
}

function normalizeCardConfig(defs, cfg){
  const metrics = Array.isArray(defs?.metrics) ? defs.metrics : [];
  const categories = new Set((Array.isArray(defs?.categories) ? defs.categories : []).map(String));
  const allowedMetricIds = new Set(metrics.map(m=>String(m?.id||'')).filter(Boolean));

  const out = { version: 1, slots: {}, categorySelected: {} };
  // slots
  const slotsIn = cfg?.slots && typeof cfg.slots === 'object' ? cfg.slots : {};
  CARD_SLOTS.forEach(s=>{ out.slots[s] = null; });
  CARD_SLOTS.forEach(s=>{
    const cat = slotsIn?.[s];
    const c = (cat == null || cat === '') ? null : String(cat);
    if(c && categories.has(c)) out.slots[s] = c;
  });
  // enforce uniqueness (first wins)
  const seen = new Set();
  CARD_SLOTS.forEach(s=>{
    const c = out.slots[s];
    if(!c) return;
    if(seen.has(c)) out.slots[s] = null;
    else seen.add(c);
  });

  // metric selections
  const selIn = cfg?.categorySelected && typeof cfg.categorySelected === 'object' ? cfg.categorySelected : {};
  categories.forEach(cat=>{
    const arr = Array.isArray(selIn?.[cat]) ? selIn[cat] : [];
    out.categorySelected[cat] = arr.map(String).filter(id=>allowedMetricIds.has(id));
  });

  return out;
}

async function exportCardConfig(){
  const defs = await ensureCardDefs();
  const cfg = __cardConfig || loadCardConfig(defs);
  const norm = normalizeCardConfig(defs, cfg);
  const text = JSON.stringify(norm, null, 2);
  downloadTextFile('skaters_card_config.json', text, 'application/json');
  try{
    if(navigator?.clipboard?.writeText){
      await navigator.clipboard.writeText(text);
    }
  }catch(_){ /* ignore clipboard failures */ }
}

async function importCardConfigFromText(text){
  const defs = await ensureCardDefs();
  const parsed = safeJsonParse(text);
  if(!parsed || typeof parsed !== 'object'){
    alert('Invalid JSON.');
    return;
  }
  const norm = normalizeCardConfig(defs, parsed);
  __cardConfig = norm;
  saveCardConfig(norm);
  renderCardConfigModal(defs, __cardConfig);
  loadCardPanel();
}

function openCardConfig(){
  if(cardConfigModal) cardConfigModal.hidden = false;
}
function closeCardConfig(){
  if(cardConfigModal) cardConfigModal.hidden = true;
}

function renderCardConfigModal(defs, cfg){
  if(!ccGrid) return;
  const categories = Array.isArray(defs?.categories) ? defs.categories : [];
  const metrics = Array.isArray(defs?.metrics) ? defs.metrics : [];
  const byCat = {};
  metrics.forEach(m=>{
    const c = String(m?.category||'').trim();
    if(!c) return;
    (byCat[c] = byCat[c] || []).push(m);
  });

  function categoryOptionsHtml(assignedCat){
    const opts = [''].concat(categories.map(String));
    return opts.map(c=>{
      const v = String(c||'');
      const sel = (v && v === String(assignedCat||'')) ? ' selected' : '';
      const label = v ? v : '(empty)';
      return `<option value="${v}"${sel}>${label}</option>`;
    }).join('');
  }

  function metricsHtmlForCategory(cat){
    const c = String(cat||'').trim();
    if(!c) return '<div class="cc-help" style="margin:10px 0 0;">Select a category to choose metrics.</div>';
    const ms = byCat[c] || [];
    const selected = new Set((cfg?.categorySelected?.[c] || []).map(String));
    const checks = ms.map(m=>{
      const id = String(m?.id||'');
      const name = String(m?.name || m?.metric || id);
      const checked = selected.has(id) ? ' checked' : '';
      return `<label class="cc-metric"><input type="checkbox" data-mid="${id}" data-cat="${c}"${checked}/><span>${name}</span></label>`;
    }).join('');
    return `<div class="cc-metrics" style="margin-top:10px;">${checks || '<div class="cc-help">No metrics</div>'}</div>`;
  }

  ccGrid.innerHTML = CARD_SLOTS.map(slot=>{
    const assignedCat = String(cfg?.slots?.[slot] || '');
    return `
      <div class="cc-slot" data-slot="${slot}">
        <div class="s">${slot}</div>
        <div class="cc-row" style="margin-top:8px; margin-bottom:0;">
          <div style="min-width:70px; font-weight:850;">Category</div>
          <select data-slot="${slot}" class="cc-assign" style="flex:1; min-width:0;">${categoryOptionsHtml(assignedCat)}</select>
        </div>
        ${metricsHtmlForCategory(assignedCat)}
      </div>
    `;
  }).join('');

  ccGrid.querySelectorAll('select.cc-assign[data-slot]').forEach(dd=>{
    dd.addEventListener('change', ()=>{
      const slot = String(dd.getAttribute('data-slot')||'');
      if(!slot) return;
      const next = String(dd.value||'');
      if(next){
        // Enforce uniqueness: selecting a used category clears it from the other slot.
        CARD_SLOTS.forEach(s=>{ if(s !== slot && cfg.slots[s] === next) cfg.slots[s] = null; });
      }
      cfg.slots[slot] = next || null;
      renderCardConfigModal(defs, cfg);
    });
  });

  ccGrid.querySelectorAll('input[type="checkbox"][data-mid][data-cat]').forEach(cb=>{
    cb.addEventListener('change', ()=>{
      const cat = cb.getAttribute('data-cat');
      const mid = cb.getAttribute('data-mid');
      if(!cat || !mid) return;
      const arr = cfg.categorySelected[cat] || (cfg.categorySelected[cat] = []);
      const i = arr.map(String).indexOf(String(mid));
      if(cb.checked){
        if(i === -1) arr.push(mid);
      }else{
        if(i !== -1) arr.splice(i, 1);
      }
    });
  });
}

async function showCardConfig(){
  const defs = await ensureCardDefs();
  __cardConfig = loadCardConfig(defs);
  renderCardConfigModal(defs, __cardConfig);
  openCardConfig();
}

function parseLocaleNumber(x){
  if(x == null) return NaN;
  if(typeof x === 'number') return x;
  let s = String(x).trim();
  if(!s) return NaN;
  s = s.replace(/\u00A0/g, ' ').replace(/\s+/g, '');
  // If both '.' and ',' exist, treat the last separator as the decimal separator.
  const lastDot = s.lastIndexOf('.');
  const lastComma = s.lastIndexOf(',');
  if(lastDot !== -1 && lastComma !== -1){
    if(lastComma > lastDot){
      // Danish-like: 1.234,56
      s = s.replace(/\./g, '').replace(/,/g, '.');
    }else{
      // US-like: 1,234.56
      s = s.replace(/,/g, '');
    }
  }else if(lastComma !== -1 && lastDot === -1){
    // Only comma present -> assume decimal comma.
    s = s.replace(/,/g, '.');
  }else{
    // Only dot present (or neither) -> Number() can handle.
  }
  const n = Number(s);
  return Number.isFinite(n) ? n : NaN;
}

function zToPercentile(z){
  const n = Number(z);
  if(!Number.isFinite(n)) return NaN;
  // Normal CDF approximation via erf
  const t = n / Math.sqrt(2);
  // Abramowitz-Stegun approximation for erf
  const sign = t < 0 ? -1 : 1;
  const a1=0.254829592, a2=-0.284496736, a3=1.421413741, a4=-1.453152027, a5=1.061405429, p=0.3275911;
  const x = Math.abs(t);
  const u = 1 / (1 + p*x);
  const y = 1 - (((((a5*u + a4)*u) + a3)*u + a2)*u + a1)*u*Math.exp(-x*x);
  const erf = sign * y;
  const cdf = 0.5 * (1 + erf);
  return cdf * 100;
}

function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

function hexToRgb(hex){
  try{
    let h = String(hex||'').trim();
    if(!h.startsWith('#')) return null;
    h = h.slice(1);
    if(h.length===3) h = h.split('').map(c=>c+c).join('');
    if(h.length!==6) return null;
    const r = parseInt(h.slice(0,2),16);
    const g = parseInt(h.slice(2,4),16);
    const b = parseInt(h.slice(4,6),16);
    if(!Number.isFinite(r)||!Number.isFinite(g)||!Number.isFinite(b)) return null;
    return {r,g,b};
  }catch(_){ return null; }
}

function mixHex(hexA, hexB, t){
  const a = hexToRgb(hexA);
  const b = hexToRgb(hexB);
  if(!a || !b) return hexA;
  const tt = clamp(Number(t)||0, 0, 1);
  const r = Math.round(a.r*(1-tt) + b.r*tt);
  const g = Math.round(a.g*(1-tt) + b.g*tt);
  const bb = Math.round(a.b*(1-tt) + b.b*tt);
  return `rgb(${r},${g},${bb})`;
}

function lerp(a,b,t){ return a*(1-t)+b*t; }
function mixRgb(rgbA, rgbB, t){
  const tt = clamp(Number(t)||0, 0, 1);
  return {
    r: Math.round(lerp(rgbA.r, rgbB.r, tt)),
    g: Math.round(lerp(rgbA.g, rgbB.g, tt)),
    b: Math.round(lerp(rgbA.b, rgbB.b, tt)),
  };
}
function pctToColor(pct){
  const p = clamp(Number(pct)||0, 0, 100);
  const red = {r:255,g:77,b:77};
  const white = {r:247,g:247,b:247};
  const blue = {r:77,g:163,b:255};
  if(p <= 50){
    const c = mixRgb(red, white, p/50);
    return `rgb(${c.r},${c.g},${c.b})`;
  }
  const c = mixRgb(white, blue, (p-50)/50);
  return `rgb(${c.r},${c.g},${c.b})`;
}

function fmtMetricValue(def, value, ratesSel){
  const v = Number(value);
  if(!Number.isFinite(v)) return '—';
  const cat = String(def?.category||'');
  const m = String(def?.metric||'');

  if(m === 'ixG' || String(def?.name||'').trim().toLowerCase() === 'individual xg'){
    return v.toFixed(1);
  }

  if(m === 'GP') return String(Math.round(v));
  if(m === 'TOI'){
    return (ratesSel === 'PerGame') ? v.toFixed(2) : v.toFixed(1);
  }
  if(m.includes('%') || m === 'PDO' || (String(def?.name||'').includes('%'))){
    if(m === 'PDO') return v.toFixed(1);
    const s = (m.startsWith('d') && v > 0) ? '+' : '';
    return s + v.toFixed(1) + '%';
  }
  if(m.endsWith('+/-') || m.includes('+/-') || m === 'GAx' || m === 'GSAx' || m === 'xG+/-' || m === 'xG+/-' || m === 'C+/-' || m === 'F+/-' || m === 'S+/-' || m === 'G+/-'){
    const s = v > 0 ? '+' : '';
    return s + v.toFixed(2);
  }
  if(m.startsWith('RAPM')) return v.toFixed(3);
  if(cat === 'Context' && (m === 'QoT' || m === 'QoC' || m === 'ZS')) return v.toFixed(3);

  // counts / rates
  return (ratesSel === 'Totals') ? String(Math.round(v)) : v.toFixed(2);
}

function displayMetricLabel(def, labels){
  const m = String(def?.metric||'');
  if(m === 'iShots or iFenwick') return String(labels?.Attempts || def?.name || 'Attempts');
  if(m === 'Sh% or FSh%') return String(labels?.Sh || def?.name || 'Sh%');
  if(m === 'xSh% or xFS%') return String(labels?.xSh || def?.name || 'xSh%');
  if(m === 'dSh% or dFSh%') return String(labels?.dSh || def?.name || 'dSh%');
  return String(def?.name || def?.metric || def?.id || '');
}

function renderCardMetric(def, metric, labels, ratesSel){
  const pct = Number(metric?.pct);
  const pctOk = Number.isFinite(pct);
  const width = pctOk ? clamp(pct, 0, 100).toFixed(1) : '0.0';
  const color = pctOk ? pctToColor(pct) : 'rgba(255,255,255,0.15)';
  const valText = fmtMetricValue(def, metric?.value, ratesSel);
  return `
    <div class="metric">
      <div class="metric-head">
        <div class="metric-name">${displayMetricLabel(def, labels)}</div>
        <div class="metric-val">${valText}</div>
      </div>
      <div class="metric-bar"><div class="metric-fill" style="width:${width}%; background:${color};"></div></div>
    </div>
  `;
}

function renderCardUI(data, defs, cfg){
  if(!cardPanelInner) return;
  const metrics = data?.metrics || {};
  const labels = data?.labels || {};
  const ratesSel = String(cardRates?.value || data?.rates || 'Totals');

  const defsMetrics = Array.isArray(defs?.metrics) ? defs.metrics : [];
  const defById = {};
  defsMetrics.forEach(d=>{ if(d?.id) defById[String(d.id)] = d; });

  const defaultsByCat = {};
  defsMetrics.forEach(d=>{
    const cat = String(d?.category||'');
    if(!cat) return;
    const isDef = String(d?.default||'').trim()==='1' || d?.default===true || String(d?.default||'').toLowerCase()==='true';
    if(!isDef) return;
    (defaultsByCat[cat] = defaultsByCat[cat] || []).push(String(d?.id||''));
  });

  const slots = cfg?.slots || {};
  const selectedByCat = cfg?.categorySelected || {};

  function slotHtml(slot){
    const cat = slots?.[slot];
    if(!cat) return '';
    let mids = Array.isArray(selectedByCat?.[cat]) ? selectedByCat[cat].map(String).filter(Boolean) : [];
    if(!mids.length) mids = (defaultsByCat[cat] || []).filter(Boolean);
    const body = mids.map(mid=>{
      const def = defById[mid] || { id: mid, category: cat, metric: mid.split('|')[1] || mid, name: mid };
      let m = metrics?.[mid];
      // Special: TOI/GP display when rates is PerGame
      if(ratesSel === 'PerGame' && mid === 'Ice Time|TOI'){
        const toi = Number(metrics?.['Ice Time|TOI']?.value);
        const gp = Number(metrics?.['Ice Time|GP']?.value);
        if(Number.isFinite(toi) && Number.isFinite(gp) && gp > 0){
          m = { value: toi / gp, pct: metrics?.['Ice Time|TOI']?.pct };
        }
      }
      return renderCardMetric(def, m, labels, ratesSel);
    }).join('');
    return `<div class="card-slot"><h3>${cat}</h3>${body || '<div class="skater-empty" style="padding:10px 0;">No metrics selected.</div>'}</div>`;
  }

  const columns = [
    ['L1','L2','L3'],
    ['C1','C2','C3'],
    ['R1','R2','R3'],
  ];
  cardPanelInner.innerHTML = `
    <div class="card-grid">
      ${columns.map(col=>`<div class="card-col">${col.map(slotHtml).join('')}</div>`).join('')}
    </div>
  `;
}

async function loadCardPanel(){
  if(!cardPanelInner) return;
  if(!cardEnabled()){
    cardPanelInner.textContent = '';
    return;
  }

  updateCardSlicerSummary();
  const playerId = String(playerSelect?.value || '').trim();
  if(!playerId){
    cardPanelInner.textContent = 'Select a player to view Card.';
    return;
  }

  const season = String(seasonSelect?.value || '').trim() || '20252026';
  const scope = String(cardScope?.value || 'season');
  const seasonState = String(cardSeasonState?.value || 'regular');
  const strengthState = String(cardStrengthState?.value || '5v5');
  const rates = String(cardRates?.value || 'Totals');
  const xgModel = String(cardXgModel?.value || 'xG_F');
  let minGP = Number.parseInt(String(cardMinGp?.value || '0'), 10);
  if(!Number.isFinite(minGP) || minGP < 0) minGP = 0;
  let minTOI = Number(String(cardMinToi?.value || '0'));
  if(!Number.isFinite(minTOI) || minTOI < 0) minTOI = 0;

  cardPanelInner.textContent = 'Loading card...';
  try{
    const defs = await ensureCardDefs();
    const cfg = (__cardConfig = loadCardConfig(defs));
    // Build requested metric list from configured categories.
    const defsMetrics = Array.isArray(defs?.metrics) ? defs.metrics : [];
    const byCat = {};
    defsMetrics.forEach(m=>{
      const c = String(m?.category||'').trim();
      if(!c) return;
      (byCat[c] = byCat[c] || []).push(m);
    });
    const metricIds = [];
    const usedCats = new Set(Object.values(cfg?.slots||{}).filter(Boolean).map(String));
    usedCats.forEach(cat=>{
      let mids = Array.isArray(cfg?.categorySelected?.[cat]) ? cfg.categorySelected[cat].map(String).filter(Boolean) : [];
      if(!mids.length){
        const defaults = (byCat[cat] || []).filter(x=>String(x?.default||'').trim()==='1' || x?.default===true || String(x?.default||'').toLowerCase()==='true');
        mids = defaults.map(x=>String(x?.id||'')).filter(Boolean);
      }
      mids.forEach(id=>{ if(id && !metricIds.includes(id)) metricIds.push(id); });
    });
    // Ensure GP is present if we need TOI/GP display.
    if(String(rates) === 'PerGame' && metricIds.includes('Ice Time|TOI') && !metricIds.includes('Ice Time|GP')){
      metricIds.push('Ice Time|GP');
    }

    const url = `/api/skaters/card?season=${encodeURIComponent(season)}&playerId=${encodeURIComponent(playerId)}&seasonState=${encodeURIComponent(seasonState)}&strengthState=${encodeURIComponent(strengthState)}&xgModel=${encodeURIComponent(xgModel)}&rates=${encodeURIComponent(rates)}&scope=${encodeURIComponent(scope)}&minGP=${encodeURIComponent(String(minGP))}&minTOI=${encodeURIComponent(String(minTOI))}&metricIds=${encodeURIComponent(metricIds.join(','))}`;
    const r = await fetch(url, { cache: 'no-store' });
    let data = null;
    try{
      data = await r.json();
    }catch(_){
      data = null;
    }
    if(!r.ok){
      const err = (data && typeof data === 'object' && data.error) ? String(data.error) : '';
      cardPanelInner.textContent = `Error loading Card (${r.status}${err?`: ${err}`:''}).`;
      return;
    }
    if(data?.error){
      if(data.error === 'not_found'){
        cardPanelInner.textContent = 'No SeasonStats found for this filter.';
        return;
      }
      cardPanelInner.textContent = 'Error loading Card.';
      return;
    }
    renderCardUI(data, defs, cfg);
  }catch(e){
    try{ console.error('[card] loadCardPanel failed:', e); }catch(_){/*noop*/}
    cardPanelInner.textContent = 'Error loading Card.';
  }
}

function themeAccent(){
  try{ return getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#4da3ff'; }catch(_){ return '#4da3ff'; }
}

function themeTextDim(){
  try{ return getComputedStyle(document.documentElement).getPropertyValue('--text-dim').trim() || '#9aa4b1'; }catch(_){ return '#9aa4b1'; }
}

function fmt3(x){
  const n = Number(x);
  if(!Number.isFinite(n)) return '';
  return n.toFixed(3);
}

function pctRank(values, v){
  const arr = (values||[]).filter(n=>Number.isFinite(n)).slice().sort((a,b)=>a-b);
  if(!arr.length || !Number.isFinite(v)) return null;
  if(arr.length === 1) return 50;
  let lo = 0, hi = arr.length;
  while(lo < hi){
    const mid = (lo+hi)>>1;
    if(arr[mid] <= v) lo = mid + 1;
    else hi = mid;
  }
  const rank = lo - 1;
  return 100 * (rank / (arr.length - 1));
}

function setActiveProjSubtab(which){
  const isP = which === 'player';
  const isT = which === 'team';
  const isL = which === 'league';
  projTabPlayer?.classList.toggle('active', isP);
  projTabTeam?.classList.toggle('active', isT);
  projTabLeague?.classList.toggle('active', isL);
  projTabPlayer?.setAttribute('aria-selected', isP ? 'true' : 'false');
  projTabTeam?.setAttribute('aria-selected', isT ? 'true' : 'false');
  projTabLeague?.setAttribute('aria-selected', isL ? 'true' : 'false');
  if(projPanelPlayer) projPanelPlayer.hidden = !isP;
  if(projPanelTeam) projPanelTeam.hidden = !isT;
  if(projPanelLeague) projPanelLeague.hidden = !isL;
}

async function ensureProjLeaguePlayers(){
  if(__projLeaguePlayers) return __projLeaguePlayers;
  let js = null;
  try{
    const r = await fetch('/api/player-projections/league', { cache:'no-store' });
    if(!r.ok){
      console.error('[projections] /api/player-projections/league failed:', r.status);
      __projLeaguePlayers = [];
      return __projLeaguePlayers;
    }
    js = await r.json();
  }catch(e){
    console.error('[projections] /api/player-projections/league failed:', e);
    __projLeaguePlayers = [];
    return __projLeaguePlayers;
  }
  __projLeaguePlayers = Array.isArray(js?.players) ? js.players : [];
  // Debug: log team distribution
  const teamCounts = {};
  __projLeaguePlayers.forEach(p => {
    const t = p.team || '(no team)';
    teamCounts[t] = (teamCounts[t] || 0) + 1;
  });
  console.log('[projections] League players by team:', teamCounts);
  console.log('[projections] Total players loaded:', __projLeaguePlayers.length);
  return __projLeaguePlayers;
}

function renderPlayerKpisFromLeague(p, ctx){
  if(!projPlayerKpis) return;
  if(!p){
    projPlayerKpis.innerHTML = '<div class="skater-empty" style="grid-column:1 / -1; padding:8px 2px;">Select a player to view projections.</div>';
    return;
  }
  const items = [
    ['Position', p.position],
    ['GP', p.gp],
    ['Age', fmt3(p.Age)],
    ['Rookie', fmt3(p.Rookie)],
    ['EVO', fmt3(p.EVO)],
    ['EVD', fmt3(p.EVD)],
    ['PP', fmt3(p.PP)],
    ['SH', fmt3(p.SH)],
    ['QoT', ctx?.QoT != null ? fmt3(ctx.QoT) : '—'],
    ['QoC', ctx?.QoC != null ? fmt3(ctx.QoC) : '—'],
    ['ZS', ctx?.ZS != null ? fmt3(ctx.ZS) : '—'],
    ['Total', fmt3(p.total)],
  ];
  projPlayerKpis.innerHTML = items.map(([k,v])=>(
    `<div class="kpi-card"><div class="kpi-title">${k}</div><div class="kpi-value">${(v==null||v==='')?'—':v}</div></div>`
  )).join('');
}

function renderPlayerRadarFromLeague(p, leaguePlayers, contextData, teamColor){
  const ctx = document.getElementById('projPlayerRadar')?.getContext('2d');
  if(!ctx) return;
  if(__projRadarChart){ try{ __projRadarChart.destroy(); }catch(_){/*noop*/} __projRadarChart=null; }
  if(!p) return;

  const metrics = ['EVO','EVD','PP','SH','QoT','QoC','ZS'];
  const groupPos = String(p.position||'F').toUpperCase().startsWith('D') ? 'D' : 'F';
  const pool = (leaguePlayers||[]).filter(x=>String(x.position||'').toUpperCase().startsWith(groupPos));
  const valuesByMetric = {};
  for(const m of metrics){ 
    if(m === 'QoT' || m === 'QoC' || m === 'ZS'){
      valuesByMetric[m] = pool.map(x=>Number(x.contextData?.[m]));
    } else {
      valuesByMetric[m] = pool.map(x=>Number(x[m]));
    }
  }
  const pct = metrics.map(m=>{
    let v;
    if(m === 'QoT' || m === 'QoC' || m === 'ZS'){
      v = Number(contextData?.[m]);
    } else {
      v = Number(p[m]);
    }
    const pr = pctRank(valuesByMetric[m], v);
    return pr==null ? 0 : pr;
  });

  const accent = teamColor || themeAccent();
  const grid = 'rgba(154,164,177,0.16)';
  const tick = themeTextDim();

  __projRadarChart = new Chart(ctx, {
    type: 'radar',
    data: {
      labels: metrics,
      datasets: [{
        label: `${p.name || p.playerId} (${groupPos})`,
        data: pct,
        borderColor: mixHex(accent, '#ffffff', 0.10),
        backgroundColor: mixHex(accent, '#ffffff', 0.35),
        pointBackgroundColor: mixHex(accent, '#ffffff', 0.10),
        pointRadius: 3,
        borderWidth: 2,
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      interaction: {
        mode: 'nearest',
        intersect: false,
      },
      plugins: {
        legend: { labels: { color: tick, font: { size: 13, weight:'700' } } },
        tooltip: { 
          callbacks: { 
            title: () => '',
            label: (ctx) => '',
            afterBody: (items) => {
              if(!items || !items[0]) return '';
              return metrics.map((m, i) => `${m}: ${pct[i].toFixed(1)}%`);
            }
          } 
        }
      },
      scales: {
        r: {
          min: 0,
          max: 100,
          ticks: { display: false },
          grid: { color: grid },
          angleLines: { color: grid },
          pointLabels: { color: tick, font: { size: 12, weight:'800' } },
        }
      }
    }
  });
}

function renderTeamStackFromLeague(team, leaguePlayers, teamColor){
  const ctx = document.getElementById('projTeamStack')?.getContext('2d');
  if(!ctx) return;
  if(__projTeamChart){ try{ __projTeamChart.destroy(); }catch(_){/*noop*/} __projTeamChart=null; }

  const list = (leaguePlayers||[])
    .filter(p=>String(p.team||'').toUpperCase() === String(team||'').toUpperCase())
    .slice()
    .sort((a,b)=>Number(b.total||0)-Number(a.total||0));

  const labels = list.map(p=>p.name || String(p.playerId));
  const metrics = ['Age','Rookie','EVO','EVD','PP','SH'];
  const accent = teamColor || themeAccent();
  const tick = themeTextDim();
  const grid = 'rgba(154,164,177,0.14)';

  const colors = [
    mixHex(accent,'#ffffff',0.05),
    mixHex(accent,'#ffffff',0.18),
    mixHex(accent,'#ffffff',0.32),
    mixHex(accent,'#ffffff',0.46),
    mixHex(accent,'#ffffff',0.60),
    mixHex(accent,'#ffffff',0.74),
  ];

  const datasets = metrics.map((m, idx)=>({
    label: m,
    data: list.map(p=>Number(p[m]||0)),
    backgroundColor: colors[idx % colors.length],
    borderColor: 'rgba(255,255,255,0.10)',
    borderWidth: 1,
  }));

  __projTeamChart = new Chart(ctx, {
    type: 'bar',
    data: { labels, datasets },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      indexAxis: 'y',
      plugins: {
        legend: { labels: { color: tick, font:{ size: 12, weight:'800' } } },
        tooltip: { callbacks: { footer: (items)=>{
          const i = items?.[0]?.dataIndex;
          if(i==null) return '';
          const t = Number(list[i]?.total);
          return Number.isFinite(t) ? `Total: ${t.toFixed(3)}` : '';
        } } }
      },
      scales: {
        x: { stacked: true, ticks: { color: tick }, grid: { color: grid } },
        y: { stacked: true, ticks: { color: tick, autoSkip: false }, grid: { display:false } },
      }
    }
  });
}

function renderLeagueTable(players, selectedPlayerId){
  if(!projLeagueTable) return;
  const cols = [
    { key:'rank', label:'Rank', num:true },
    { key:'name', label:'Player', name:true },
    { key:'team', label:'Team' },
    { key:'position', label:'Pos' },
    { key:'gp', label:'GP', num:true },
    { key:'Age', label:'Age', num:true },
    { key:'Rookie', label:'Rookie', num:true },
    { key:'EVO', label:'EVO', num:true },
    { key:'EVD', label:'EVD', num:true },
    { key:'PP', label:'PP', num:true },
    { key:'SH', label:'SH', num:true },
    { key:'QoT', label:'QoT', num:true },
    { key:'QoC', label:'QoC', num:true },
    { key:'ZS', label:'ZS', num:true },
    { key:'total', label:'Total', num:true },
  ];

  const sortKey = __projLeagueSort.key;
  const sortDir = __projLeagueSort.dir;
  const list = (players||[]).filter(p=>p.name && String(p.name).trim()).slice();
  list.sort((a,b)=>{
    const av = a?.[sortKey];
    const bv = b?.[sortKey];
    const an = Number(av);
    const bn = Number(bv);
    let cmp = 0;
    if(Number.isFinite(an) && Number.isFinite(bn)) cmp = an - bn;
    else cmp = String(av||'').localeCompare(String(bv||''));
    return sortDir==='asc' ? cmp : -cmp;
  });

  // Add rank based on sorted position
  list.forEach((p, i) => { p._rank = i + 1; });

  const head = `<thead><tr>${cols.map(c=>{
    const active = c.key === sortKey;
    const ind = active ? `<span class="sort-ind">${sortDir==='asc'?'▲':'▼'}</span>` : '';
    const cls = c.name ? 'name' : (c.num ? 'num' : '');
    return `<th class="${cls}" data-key="${c.key}">${c.label}${ind}</th>`;
  }).join('')}</tr></thead>`;

  const body = `<tbody>${list.map(p=>{
    const isSelected = String(p.playerId) === String(selectedPlayerId||'');
    const rowCls = isSelected ? ' class="selected-player"' : '';
    const td = (val, num, isName)=>{
      if(num){
        const n = Number(val);
        const s = Number.isFinite(n) ? (Number.isInteger(n) ? String(n) : n.toFixed(3)) : '';
        return `<td class="num">${s || '—'}</td>`;
      }
      if(isName){
        return `<td class="name">${(val==null||val==='')?'—':String(val)}</td>`;
      }
      return `<td>${(val==null||val==='')?'—':String(val)}</td>`;
    };
    return `<tr${rowCls}>
      ${td(p._rank,true,false)}
      ${td(p.name,false,true)}
      ${td(p.team,false,false)}
      ${td(p.position,false,false)}
      ${td(p.gp,true,false)}
      ${td(p.Age,true,false)}
      ${td(p.Rookie,true,false)}
      ${td(p.EVO,true,false)}
      ${td(p.EVD,true,false)}
      ${td(p.PP,true,false)}
      ${td(p.SH,true,false)}
      ${td(p.contextData?.QoT,true,false)}
      ${td(p.contextData?.QoC,true,false)}
      ${td(p.contextData?.ZS,true,false)}
      ${td(p.total,true,false)}
    </tr>`;
  }).join('')}</tbody>`;

  projLeagueTable.innerHTML = head + body;
  projLeagueTable.querySelectorAll('th[data-key]').forEach(th=>{
    th.addEventListener('click', ()=>{
      const k = th.getAttribute('data-key');
      if(!k) return;
      if(__projLeagueSort.key === k){
        __projLeagueSort.dir = (__projLeagueSort.dir === 'asc') ? 'desc' : 'asc';
      }else{
        __projLeagueSort.key = k;
        __projLeagueSort.dir = k === 'name' || k === 'team' || k === 'position' ? 'asc' : 'desc';
      }
      renderLeagueTable(__projLeaguePlayers, playerSelect?.value);
    });
  });
}

function getAccentColor(){
  try{
    return getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#4da3ff';
  }catch(e){
    return '#4da3ff';
  }
}

function hexToRgb(hex){
  const s = String(hex||'').trim().replace('#','');
  if(s.length !== 6) return null;
  const r = parseInt(s.slice(0,2),16);
  const g = parseInt(s.slice(2,4),16);
  const b = parseInt(s.slice(4,6),16);
  if(!Number.isFinite(r) || !Number.isFinite(g) || !Number.isFinite(b)) return null;
  return {r,g,b};
}

function lerp(a,b,t){ return a + (b-a)*t; }

function percentileToColor(pct){
  const p = clamp(Number(pct), 0, 100);
  const red = hexToRgb('#ff6a6a');
  const white = hexToRgb('#f1f5f9');
  const blue = hexToRgb('#4da3ff');
  if(!red || !white || !blue) return getAccentColor();
  if(p <= 50){
    const t = p / 50;
    const r = Math.round(lerp(red.r, white.r, t));
    const g = Math.round(lerp(red.g, white.g, t));
    const b = Math.round(lerp(red.b, white.b, t));
    return `rgb(${r},${g},${b})`;
  }
  const t = (p - 50) / 50;
  const r = Math.round(lerp(white.r, blue.r, t));
  const g = Math.round(lerp(white.g, blue.g, t));
  const b = Math.round(lerp(white.b, blue.b, t));
  return `rgb(${r},${g},${b})`;
}

function normRatesTotals(v){
  const s = String(v || '').trim().toLowerCase();
  if(s.startsWith('tot')) return 'Totals';
  if(s.startsWith('rate')) return 'Rates';
  return v;
}

function pickRow(rows, ratesTotals){
  const want = normRatesTotals(ratesTotals);
  // Prefer 5v5 row since it carries PP/SH columns too
  let r = rows.find(x => String(x.StrengthState||'') === '5v5' && normRatesTotals(x.Rates_Totals) === want);
  if(!r) r = rows.find(x => normRatesTotals(x.Rates_Totals) === want);
  if(!r) r = rows[0];
  return r || null;
}

function pickStrengthRow(rows, strength, ratesTotals){
  const want = normRatesTotals(ratesTotals);
  return rows.find(x => String(x.StrengthState||'') === strength && normRatesTotals(x.Rates_Totals) === want) || null;
}

function pickCtxRow(rows, strength){
  return rows.find(x => String(x.StrengthState||'') === strength) || null;
}

function applyRAPMSelectTextColor(){
  if(!teamSelect) return;
  const c = getComputedStyle(teamSelect).color;
  ['rapmPeriod','rapmCareerStrength','rapmMetric','rapmRatesTotals','rapmOutput','rapmZRange'].forEach(id=>{
    const el = document.getElementById(id);
    if(el) el.style.color = c;
  });
}

function applyExportButtonTextColor(){
  if(!teamSelect || !projExportCsv) return;
  const c = getComputedStyle(teamSelect).color;
  projExportCsv.style.color = c;
}

function clamp(v, lo, hi){
  return Math.max(lo, Math.min(hi, v));
}

function buildBarsFromRows(row5, rowPP, rowSH, opts){
  const metric = opts.metric;
  const output = opts.output;
  const pct = opts.percentiles || null;

  if(output === 'pct' && pct){
    return {
      fivev5: [
        { key: '5v5_off', label: 'Off', value: pct['5v5_off'] },
        { key: '5v5_def', label: 'Def', value: pct['5v5_def'] },
        { key: '5v5_diff', label: 'Diff', value: pct['5v5_diff'] },
      ],
      pp: [
        { key: 'pp_off', label: 'Off', value: pct['pp_off'] },
      ],
      sh: [
        { key: 'sh_def', label: 'Def', value: pct['sh_def'] },
      ],
    };
  }

  function getValue(row, colOrCols, invert=false){
    const cols = Array.isArray(colOrCols) ? colOrCols : [colOrCols];
    for(const col of cols){
      const n = parseLocaleNumber(row?.[col]);
      if(Number.isFinite(n)) return invert ? -n : n;
    }
    return NaN;
  }
  function getZ(row, colOrCols, invert=false){
    const cols = Array.isArray(colOrCols) ? colOrCols : [colOrCols];
    for(const col of cols){
      const n = parseLocaleNumber(row?.[col]);
      if(Number.isFinite(n)) return invert ? -n : n;
    }
    return NaN;
  }

  const map = {
    corsi: {
      off: ['CF', 'CF_zscore', false],
      def: ['CA', 'CA_zscore', true],
      diff: ['C_plusminus', 'C_plusminus_zscore', false],
      pp: [['PP_CF', 'CF'], ['PP_CF_zscore', 'CF_zscore'], false],
      sh: [['SH_CA', 'CA'], ['SH_CA_zscore', 'CA_zscore'], true],
    },
    xg: {
      off: ['xGF', 'xGF_zscore', false],
      def: ['xGA', 'xGA_zscore', true],
      diff: ['xG_plusminus', 'xG_plusminus_zscore', false],
      pp: [['PP_xGF', 'xGF'], ['PP_xGF_zscore', 'xGF_zscore'], false],
      sh: [['SH_xGA', 'xGA'], ['SH_xGA_zscore', 'xGA_zscore'], true],
    },
    goals: {
      off: ['GF', 'GF_zscore', false],
      def: ['GA', 'GA_zscore', true],
      diff: ['G_plusminus', 'G_plusminus_zscore', false],
      pp: [['PP_GF', 'GF'], ['PP_GF_zscore', 'GF_zscore'], false],
      sh: [['SH_GA', 'GA'], ['SH_GA_zscore', 'GA_zscore'], true],
    }
  };
  const m = map[metric] || map.corsi;

  function get(row, col, zcol, invert){
    if(output === 'z') return getZ(row, zcol, invert);
    if(output === 'pct'){
      const z = getZ(row, zcol, invert);
      const p = zToPercentile(z);
      return p;
    }
    return getValue(row, col, invert);
  }

  return {
    fivev5: [
      { key: '5v5_off', label: 'Off', value: get(row5, ...m.off) },
      { key: '5v5_def', label: 'Def', value: get(row5, ...m.def) },
      { key: '5v5_diff', label: 'Diff', value: get(row5, ...m.diff) },
    ],
    pp: [
      { key: 'pp_off', label: 'Off', value: get(rowPP, ...m.pp) },
    ],
    sh: [
      { key: 'sh_def', label: 'Def', value: get(rowSH, ...m.sh) },
    ],
  };
}

function renderBarSection(title, bars, scale){
  const axis = (()=>{
    if(scale.mode === 'pct'){
      return { min: 0, max: 100, midPct: 50, topLabel: '100', midLabel: '50', botLabel: '0' };
    }
    const min = Number(scale.min);
    const max = Number(scale.max);
    if(!Number.isFinite(min) || !Number.isFinite(max) || min === max){
      const r = Number.isFinite(scale.range) ? Number(scale.range) : 2;
      return { min: -r, max: r, zeroPct: 50, topLabel: fmtNum(r, 2), midLabel: '0', botLabel: fmtNum(-r, 2) };
    }
    const denom = (max - min) || 1;
    let zeroPct = ((max - 0) / denom) * 100;
    zeroPct = clamp(zeroPct, 0, 100);
    return { min, max, zeroPct, topLabel: fmtNum(max, 3), midLabel: '0', botLabel: fmtNum(min, 3) };
  })();

  const axisHtml = `
    <div class="rapm-axis">
      <div class="lbl top">${axis.topLabel}</div>
      <div class="lbl mid" style="top:${scale.mode === 'pct' ? axis.midPct : axis.zeroPct}%;">${axis.midLabel}</div>
      <div class="lbl bot">${axis.botLabel}</div>
    </div>
  `;

  const cols = bars.map(b => {
    const raw = Number(b.value);
    const ok = Number.isFinite(raw);
    const v = ok ? raw : 0;

    let topPct = 50;
    let heightPct = 0;
    let neg = false;
    let color = '#4da3ff';

    if(scale.mode === 'pct'){
      const p = clamp(v, 0, 100);
      topPct = 100 - p;
      heightPct = p;
      color = percentileToColor(p);
    }else{
      const min = axis.min;
      const max = axis.max;
      const denom = (max - min) || 1;
      const y = (val)=> ((max - val) / denom) * 100;
      const z0 = axis.zeroPct;
      const yv = y(v);
      topPct = Math.min(yv, z0);
      heightPct = Math.abs(yv - z0);
      neg = v < 0;
      color = neg ? '#ff6a6a' : '#4da3ff';
    }

    const label = ok ? (scale.mode === 'pct' ? `${fmtNum(v, 1)}%` : fmtNum(v, 3)) : '';

    return `
      <div class="bar-col">
        <div class="bar-area">
          ${scale.mode === 'pct'
            ? `<div class="bar-line" style="top:${axis.midPct}%;"></div>`
            : `<div class="bar-line" style="top:${axis.zeroPct}%;"></div>`
          }
          <div class="bar ${neg ? 'neg' : ''}" style="top:${topPct}%; height:${heightPct}%; background:${color};"></div>
        </div>
        <div class="bar-label">${b.label}</div>
        <div class="bar-value">${label}</div>
      </div>
    `;
  }).join('');

  return `
    <div class="rapm-sect">
      <h3>${title}</h3>
      <div class="rapm-row">${axisHtml}<div class="bars">${cols}</div></div>
      <div class="toi" data-toi="${title}"></div>
    </div>
  `;
}

function renderNotEnoughSection(title, minsStr, threshold){
  return `
    <div class="rapm-sect">
      <h3>${title}</h3>
      <div class="skater-empty" style="padding:18px 8px;">Not enough data</div>
      <div class="toi">${minsStr ? `TOI: ${minsStr} min` : 'TOI: -'}${threshold ? ` (min ${threshold})` : ''}</div>
    </div>
  `;
}

function renderRAPMUI(){
  if(!rapmPanelInner) return;
  rapmPanelInner.className = '';
  rapmPanelInner.innerHTML = `
    <div class="rapm-controls">
      <label>Period
        <select id="rapmPeriod">
          <option value="season">Season</option>
          <option value="career">Career</option>
        </select>
      </label>
      <label id="rapmCareerStrengthWrap" style="display:none;">Strength
        <select id="rapmCareerStrength">
          <option value="All">All</option>
          <option value="5v5">5v5</option>
          <option value="PP">PP</option>
          <option value="SH">SH</option>
        </select>
      </label>
      <label>Metric
        <select id="rapmMetric">
          <option value="corsi">Corsi</option>
          <option value="xg">xG</option>
          <option value="goals">Goals</option>
        </select>
      </label>
      <label>Rates/Totals
        <select id="rapmRatesTotals">
          <option value="Rates">Rates</option>
          <option value="Totals">Totals</option>
        </select>
      </label>
      <label>Output
        <select id="rapmOutput">
          <option value="value">Value</option>
          <option value="pct">Percentile</option>
          <option value="z">Z-Score</option>
        </select>
      </label>
      <label id="rapmRangeWrap" style="display:none;">Range
        <select id="rapmZRange">
          <option value="1">±1</option>
          <option value="2" selected>±2</option>
          <option value="3">±3</option>
          <option value="4">±4</option>
          <option value="5">±5</option>
        </select>
      </label>
    </div>
    <div id="rapmChart"></div>
    <div id="rapmCareer" class="rapm-career" style="display:none;"></div>
  `;

  const periodSel = document.getElementById('rapmPeriod');
  const careerStrengthWrap = document.getElementById('rapmCareerStrengthWrap');
  const careerStrengthSel = document.getElementById('rapmCareerStrength');
  const metricSel = document.getElementById('rapmMetric');
  const rtSel = document.getElementById('rapmRatesTotals');
  const outSel = document.getElementById('rapmOutput');
  const rangeWrap = document.getElementById('rapmRangeWrap');
  const rangeSel = document.getElementById('rapmZRange');

  function prefKey(k){ return `skaters_rapm_${k}`; }
  function loadPrefs(){
    try{
      const p = localStorage.getItem(prefKey('period'));
      const cs = localStorage.getItem(prefKey('careerStrength'));
      const m = localStorage.getItem(prefKey('metric'));
      const rt = localStorage.getItem(prefKey('ratesTotals'));
      const o = localStorage.getItem(prefKey('output'));
      const zr = localStorage.getItem(prefKey('zRange'));
      if(p && periodSel && Array.from(periodSel.options).some(x=>x.value===p)) periodSel.value = p;
      if(cs && careerStrengthSel && Array.from(careerStrengthSel.options).some(x=>x.value===cs)) careerStrengthSel.value = cs;
      if(m && metricSel && Array.from(metricSel.options).some(x=>x.value===m)) metricSel.value = m;
      if(rt && rtSel && Array.from(rtSel.options).some(x=>x.value===rt)) rtSel.value = rt;
      if(o && outSel && Array.from(outSel.options).some(x=>x.value===o)) outSel.value = o;
      if(zr && rangeSel && Array.from(rangeSel.options).some(x=>x.value===zr)) rangeSel.value = zr;
    }catch(e){/* ignore */}
  }
  function savePrefs(){
    try{
      if(periodSel) localStorage.setItem(prefKey('period'), String(periodSel.value||''));
      if(careerStrengthSel) localStorage.setItem(prefKey('careerStrength'), String(careerStrengthSel.value||''));
      if(metricSel) localStorage.setItem(prefKey('metric'), String(metricSel.value||''));
      if(rtSel) localStorage.setItem(prefKey('ratesTotals'), String(rtSel.value||''));
      if(outSel) localStorage.setItem(prefKey('output'), String(outSel.value||''));
      if(rangeSel) localStorage.setItem(prefKey('zRange'), String(rangeSel.value||''));
    }catch(e){/* ignore */}
  }

  loadPrefs();
  applyRAPMSelectTextColor();

  function update(){
    savePrefs();
    if(!__rapmCache) return;
    const rows = Array.isArray(__rapmCache?.rows) ? __rapmCache.rows : [];
    const ctxRows = Array.isArray(__ctxCache?.rows) ? __ctxCache.rows : [];
    if(!rows.length){
      const chart = document.getElementById('rapmChart');
      if(chart) chart.innerHTML = '<div class="skater-empty">No RAPM data.</div>';
      return;
    }

    const output = String(outSel?.value || 'value');
    const mode = output === 'pct' ? 'pct' : (output === 'z' ? 'z' : 'value');
    const zRange = parseLocaleNumber(rangeSel?.value || '2');
    if(rangeWrap) rangeWrap.style.display = (output === 'z') ? '' : 'none';

    const period = String(periodSel?.value || 'season');
    const chart = document.getElementById('rapmChart');
    const career = document.getElementById('rapmCareer');
    if(careerStrengthWrap) careerStrengthWrap.style.display = (period === 'career') ? '' : 'none';
    if(chart) chart.style.display = (period === 'career') ? 'none' : '';
    if(career) career.style.display = (period === 'career') ? '' : 'none';
    applyRAPMSelectTextColor();

    if(period === 'career'){
      renderRAPMCareer({
        playerId: String(playerSelect?.value || ''),
        ratesTotals: String(rtSel?.value || 'Rates'),
        metric: String(metricSel?.value || 'corsi'),
        output,
        zRange,
        strength: String(careerStrengthSel?.value || '5v5'),
      });
      return;
    }

    const opts = {
      metric: String(metricSel?.value || 'corsi'),
      ratesTotals: String(rtSel?.value || 'Rates'),
      output: output,
      zRange: zRange,
    };
    const row5 = pickStrengthRow(rows, '5v5', opts.ratesTotals) || pickRow(rows, opts.ratesTotals);
    const rowPP = pickStrengthRow(rows, 'PP', opts.ratesTotals) || row5;
    const rowSH = pickStrengthRow(rows, 'SH', opts.ratesTotals) || row5;
    const mins5 = parseLocaleNumber(pickCtxRow(ctxRows, '5v5')?.Minutes);
    const minsp = parseLocaleNumber(pickCtxRow(ctxRows, 'PP')?.Minutes);
    const minss = parseLocaleNumber(pickCtxRow(ctxRows, 'SH')?.Minutes);
    const elig5 = Number.isFinite(mins5) && mins5 >= 100;
    const eligp = Number.isFinite(minsp) && minsp >= 40;
    const eligs = Number.isFinite(minss) && minss >= 40;

    if(!chart) return;

    if(!elig5 && !eligp && !eligs){
      chart.innerHTML = '<div class="skater-empty">Not enough data.</div>';
      return;
    }

    const season = String(seasonSelect?.value || '');
    const scaleKey = `${season}|${opts.ratesTotals}|${opts.metric}`;
    if(mode === 'value' || mode === 'pct'){
      if(__scaleKey !== scaleKey){ __scaleKey = scaleKey; __scaleCache = null; }
    }

    const renderWithScale = (scale)=>{
      const thresholds = scale?.thresholds || { fivev5: 100, pp: 40, sh: 40 };
      const playerPct = scale?.player?.percentiles || null;
      const bars = buildBarsFromRows(row5, rowPP, rowSH, { metric: opts.metric, output: output, percentiles: playerPct });

      const five = scale?.fivev5 || {};
      const pp = scale?.pp || {};
      const sh = scale?.sh || {};

      const mins5s = fmtNum(mins5, 1);
      const minsps = fmtNum(minsp, 1);
      const minsss = fmtNum(minss, 1);

      const sect5 = elig5
        ? renderBarSection('5v5', bars.fivev5, {mode, min: five.min, max: five.max, range: zRange})
        : renderNotEnoughSection('5v5', mins5s, thresholds.fivev5);
      const sectP = eligp
        ? renderBarSection('PP', bars.pp, {mode, min: pp.min, max: pp.max, range: zRange})
        : renderNotEnoughSection('PP', minsps, thresholds.pp);
      const sectS = eligs
        ? renderBarSection('SH', bars.sh, {mode, min: sh.min, max: sh.max, range: zRange})
        : renderNotEnoughSection('SH', minsss, thresholds.sh);

      chart.innerHTML = `<div class="rapm-split">${sect5}${sectP}${sectS}</div>`;

      // Fill TOI labels for eligible sections
      try{
        const map = {
          '5v5': mins5s ? `TOI: ${mins5s} min` : 'TOI: -',
          'PP':  minsps ? `TOI: ${minsps} min` : 'TOI: -',
          'SH':  minsss ? `TOI: ${minsss} min` : 'TOI: -',
        };
        chart.querySelectorAll('.toi[data-toi]').forEach(el=>{
          const k = String(el.getAttribute('data-toi') || '').trim();
          if(map[k]) el.textContent = map[k];
        });
      }catch(e){ /* ignore */ }
    };

    if(mode === 'value' || mode === 'pct'){
      if(!__scaleCache){
        chart.innerHTML = '<div class="skater-empty">Loading scale...</div>';
        const pid = String(playerSelect?.value || '');
        const pidQ = pid ? `&playerId=${encodeURIComponent(pid)}` : '';
        fetch(`/api/rapm/scale?season=${encodeURIComponent(season)}&rates=${encodeURIComponent(opts.ratesTotals)}&metric=${encodeURIComponent(opts.metric)}${pidQ}`)
          .then(r=>r.json())
          .then(j=>{ __scaleCache = j; renderWithScale(j); })
          .catch(()=>{ __scaleCache = {}; renderWithScale({}); });
        return;
      }
      renderWithScale(__scaleCache);
      return;
    }

    if(mode === 'pct'){
      renderWithScale({ fivev5:{min:0,max:100}, pp:{min:0,max:100}, sh:{min:0,max:100} });
      return;
    }

    renderWithScale({ fivev5:{min:-zRange,max:zRange}, pp:{min:-zRange,max:zRange}, sh:{min:-zRange,max:zRange} });
    return;
  }

  periodSel?.addEventListener('change', update);
  careerStrengthSel?.addEventListener('change', update);
  metricSel?.addEventListener('change', update);
  rtSel?.addEventListener('change', update);
  outSel?.addEventListener('change', update);
  rangeSel?.addEventListener('change', update);
  update();
}

async function renderRAPMCareer(opts){
  const wrap = document.getElementById('rapmCareer');
  if(!wrap) return;
  wrap.innerHTML = '<div class="skater-empty">Loading career RAPM...</div>';

  const playerId = String(opts?.playerId || '').trim();
  if(!playerId){
    wrap.innerHTML = '<div class="skater-empty">Select a player to view RAPM.</div>';
    return;
  }

  const metric = String(opts?.metric || 'corsi');
  const ratesTotals = String(opts?.ratesTotals || 'Rates');
  const output = String(opts?.output || 'value');
  const mode = output === 'pct' ? 'pct' : (output === 'z' ? 'z' : 'value');
  const zRange = parseLocaleNumber(opts?.zRange || 2);
  const strength = String(opts?.strength || '5v5');

  try{
    const url = `/api/rapm/career?playerId=${encodeURIComponent(playerId)}&rates=${encodeURIComponent(ratesTotals)}&metric=${encodeURIComponent(metric)}&strength=${encodeURIComponent(strength)}`;
    const r = await fetch(url, { cache: 'no-store' });
    const data = await r.json();
    const points = Array.isArray(data?.points) ? data.points.slice() : [];
    points.sort((a,b)=>parseInt(a?.Season||0,10) - parseInt(b?.Season||0,10));

    const title = strength === '5v5' ? '5v5' : (strength === 'PP' ? 'PP' : 'SH');
    const isAll = (strength === 'All');
    const panelTitle = isAll ? 'ALL' : title;

    function num(x){
      const n = parseLocaleNumber(x);
      return Number.isFinite(n) ? n : null;
    }
    function fmtSigned(x){
      const n = num(x);
      if(n == null) return '';
      const s = (n > 0) ? '+' : '';
      return s + n.toFixed(3);
    }
    function pickValue(p, key){
      if(isAll){
        if(mode === 'pct') return num(p?.all_total_pct);
        if(mode === 'z') return num(p?.all_total_z);
        return num(p?.all_total);
      }
      if(title === 'PP'){
        if(mode === 'pct') return num(p?.pp_off_pct);
        if(mode === 'z') return num(p?.pp_off_z);
        return num(p?.pp_off);
      }
      if(title === 'SH'){
        if(mode === 'pct') return num(p?.sh_def_pct);
        if(mode === 'z') return num(p?.sh_def_z);
        return num(p?.sh_def);
      }
      // 5v5
      const base = (key === 'total') ? '5v5_total' : `5v5_${key}`;
      if(mode === 'pct') return num(p?.[`${base}_pct`]);
      if(mode === 'z') return num(p?.[`${base}_z`]);
      return num(p?.[base]);
    }

    // y-scale
    let yMin = null;
    let yMax = null;
    if(mode === 'pct'){
      yMin = 0; yMax = 100;
    }else if(mode === 'z'){
      yMin = -zRange; yMax = zRange;
    }else{
      yMin = num(data?.scale?.min);
      yMax = num(data?.scale?.max);
      if(yMin == null || yMax == null || yMin === yMax){
        const vals = [];
        for(const p of points){
          if(isAll){
            const v = pickValue(p,'total'); if(v != null) vals.push(v);
          }else if(title === '5v5'){
            ['off','def','total'].forEach(k=>{ const v = pickValue(p,k); if(v != null) vals.push(v); });
          }else if(title === 'PP'){
            const v = pickValue(p,'off'); if(v != null) vals.push(v);
          }else{
            const v = pickValue(p,'def'); if(v != null) vals.push(v);
          }
        }
        if(vals.length){ yMin = Math.min(...vals); yMax = Math.max(...vals); }
        else { yMin = -1; yMax = 1; }
        if(yMin === yMax){ yMin -= 1; yMax += 1; }
      }
    }

    const w = 820;
    const h = 420;
    const padL = 12;
    const padR = 12;
    const padT = 12;
    const padB = 34;
    const edgePad = 26;
    const plotW = w - padL - padR;
    const plotH = h - padT - padB;
    const n = Math.max(points.length, 2);
    const xAt = (i)=> {
      const denom = (n - 1) || 1;
      const innerW = Math.max(0, plotW - (edgePad * 2));
      return padL + edgePad + (innerW * i / denom);
    };
    const yAt = (v)=>{
      const t = (v - yMin) / (yMax - yMin);
      return padT + (plotH * (1 - t));
    };

    // axis labels (same layout as bars)
    const axisMax = (mode === 'pct') ? '100' : (mode === 'z') ? `+${zRange.toFixed(1)}` : fmtSigned(yMax);
    const axisMid = (mode === 'pct') ? '50' : '0';
    const axisMin = (mode === 'pct') ? '0' : (mode === 'z') ? `-${zRange.toFixed(1)}` : fmtSigned(yMin);
    const axisHtml = `
      <div class="rapm-axis">
        <div class="lbl top">${axisMax}</div>
        <div class="lbl mid" style="top:50%;">${axisMid}</div>
        <div class="lbl bot">${axisMin}</div>
      </div>`;

    function buildSegments(getVal){
      const segs = [];
      let cur = [];
      for(let i=0;i<points.length;i++){
        const v = getVal(points[i]);
        if(v == null){
          if(cur.length >= 2) segs.push(cur);
          cur = [];
          continue;
        }
        cur.push({x:xAt(i), y:yAt(v)});
      }
      if(cur.length >= 2) segs.push(cur);
      return segs;
    }

    const svgs = [];
    const midY = yAt(0);
    svgs.push(`<line x1="${padL}" y1="${midY.toFixed(2)}" x2="${(w-padR)}" y2="${midY.toFixed(2)}" stroke="rgba(255,255,255,0.18)" stroke-width="1" />`);

    const lines = (isAll)
      ? [{key:'total', color:'rgba(255,255,255,0.92)'}]
      : (title === '5v5')
        ? [
            {key:'off', color:'#2f6bff'},
            {key:'def', color:'#ff3b30'},
            {key:'total', color:'rgba(255,255,255,0.92)'}
          ]
        : (title === 'PP')
          ? [{key:'off', color:'#2f6bff'}]
          : [{key:'def', color:'#ff3b30'}];

    const lineLabel = (lnKey)=>{
      if(isAll) return 'Total';
      if(title === 'PP') return 'Off';
      if(title === 'SH') return 'Def';
      if(lnKey === 'off') return 'Off';
      if(lnKey === 'def') return 'Def';
      return 'Total';
    };

    const fmtTooltipVal = (v)=>{
      if(v == null) return '—';
      if(mode === 'pct') return `${v.toFixed(0)}%`;
      if(mode === 'z'){
        const s = (v > 0) ? '+' : '';
        return s + v.toFixed(2);
      }
      return fmtSigned(v);
    };

    let any = false;
    for(const ln of lines){
      const segs = buildSegments(p=>pickValue(p, ln.key));
      for(const seg of segs){
        any = true;
        const pts = seg.map(pt=>`${pt.x.toFixed(2)},${pt.y.toFixed(2)}`).join(' ');
        svgs.push(`<polyline fill="none" stroke="${ln.color}" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" points="${pts}" />`);
      }
      for(let i=0;i<points.length;i++){
        const v = pickValue(points[i], ln.key);
        if(v == null) continue;
        any = true;
        svgs.push(`<circle cx="${xAt(i).toFixed(2)}" cy="${yAt(v).toFixed(2)}" r="3" fill="${ln.color}" />`);
      }
    }

    const ticks = [];
    for(let i=0;i<points.length;i++){
      const s = formatSeasonShort(points[i]?.Season);
      if(!s) continue;
      const show = (i === 0) || (i === points.length - 1) || (i % 2 === 0);
      if(!show) continue;
      ticks.push(`<text x="${xAt(i).toFixed(2)}" y="${(h-10)}" text-anchor="middle" fill="rgba(255,255,255,0.7)" font-size="14">${s}</text>`);
    }

    const plot = any
      ? `<div class="bar-area career-area"><svg viewBox="0 0 ${w} ${h}" preserveAspectRatio="none">${svgs.join('')}${ticks.join('')}</svg></div>`
      : `<div class="skater-empty" style="padding:18px 8px;">Not enough data</div>`;

    wrap.innerHTML = `
      <div class="rapm-sect" style="--rapmBarH: 420px;">
        <h3>${panelTitle}</h3>
        <div class="rapm-row">${axisHtml}${plot}</div>
        ${(!isAll && title === '5v5') ? `
          <div class="rapm-career-legend">
            <span><span class="sw" style="background:#2f6bff"></span>Off</span>
            <span><span class="sw" style="background:#ff3b30"></span>Def</span>
            <span><span class="sw" style="background:rgba(255,255,255,0.92)"></span>Total</span>
          </div>` : ''}
      </div>
    `;

    // Tooltip
    try{
      const area = wrap.querySelector('.career-area');
      const svg = wrap.querySelector('.career-area svg');
      if(area && svg && points.length){
        area.style.position = 'relative';
        let tip = wrap.querySelector('.rapm-tooltip');
        if(!tip){
          tip = document.createElement('div');
          tip.className = 'rapm-tooltip';
          area.appendChild(tip);
        }

        const seasons = points.map(p=>formatSeasonShort(p?.Season));
        const series = lines.map(ln=>({
          key: ln.key,
          label: lineLabel(ln.key),
          color: ln.color,
          values: points.map(p=>pickValue(p, ln.key)),
        }));

        const nearestIndex = (xPx)=>{
          const rect = svg.getBoundingClientRect();
          const t = (xPx - rect.left) / Math.max(1, rect.width);
          const xSvg = t * w;
          let bestI = 0;
          let bestD = Infinity;
          for(let i=0;i<points.length;i++){
            const d = Math.abs(xAt(i) - xSvg);
            if(d < bestD){ bestD = d; bestI = i; }
          }
          return bestI;
        };

        const renderTip = (i)=>{
          const title = seasons[i] || '';
          const rows = [];
          for(const s of series){
            const v = s.values[i];
            if(v == null) continue;
            rows.push(`<div class="t-row"><span class="lbl"><span class="dot" style="background:${s.color}"></span>${s.label}</span><span class="val">${fmtTooltipVal(v)}</span></div>`);
          }
          tip.innerHTML = `<div class="t-title">${title}</div>${rows.join('')}`;
        };

        const moveTip = (evt)=>{
          const rect = svg.getBoundingClientRect();
          const i = nearestIndex(evt.clientX);
          renderTip(i);
          tip.style.display = 'block';
          const x = evt.clientX - rect.left;
          const y = evt.clientY - rect.top;
          const pad = 12;
          // place to the right/up when possible
          const areaRect = area.getBoundingClientRect();
          const maxX = areaRect.width;
          const maxY = areaRect.height;
          // measure after content
          const tw = tip.offsetWidth || 180;
          const th = tip.offsetHeight || 80;
          let left = x + 14;
          let top = y - th - 14;
          if(left + tw + pad > maxX) left = x - tw - 14;
          if(top < pad) top = y + 14;
          left = Math.max(pad, Math.min(maxX - tw - pad, left));
          top = Math.max(pad, Math.min(maxY - th - pad, top));
          tip.style.left = `${left}px`;
          tip.style.top = `${top}px`;
        };

        const hideTip = ()=>{ tip.style.display = 'none'; };
        area.addEventListener('mousemove', moveTip);
        area.addEventListener('mouseleave', hideTip);
        area.addEventListener('touchstart', (e)=>{
          if(!e.touches || !e.touches[0]) return;
          moveTip(e.touches[0]);
        }, {passive:true});
        area.addEventListener('touchmove', (e)=>{
          if(!e.touches || !e.touches[0]) return;
          moveTip(e.touches[0]);
        }, {passive:true});
        area.addEventListener('touchend', hideTip);
      }
    }catch(_){ /* ignore tooltip failures */ }
  }catch(e){
    wrap.innerHTML = '<div class="skater-empty">Error loading career RAPM.</div>';
  }
}

function formatSeasonShort(seasonVal){
  const n = parseInt(String(seasonVal || '').replace(/\D/g,''), 10);
  if(!Number.isFinite(n)) return '';
  const start = Math.floor(n / 10000);
  const end = n % 10000;
  if(!start || !end) return '';
  const a = String(start).slice(-2);
  const b = String(end).slice(-2);
  return `${a}/${b}`;
}

function fmtNum(x, digits=3){
  const n = parseLocaleNumber(x);
  if(!Number.isFinite(n)) return '';
  return n.toFixed(digits);
}

async function loadRAPMPanel(){
  if(!rapmPanelInner) return;
  const playerId = playerSelect?.value;
  const season = seasonSelect?.value;
  if(!playerId){
    rapmPanelInner.textContent = 'Select a player to view RAPM.';
    return;
  }
  rapmPanelInner.textContent = 'Loading RAPM...';
  try{
    const key = `${playerId}|${season||''}`;
    if(__rapmKey !== key){
      __rapmKey = key;
      __rapmCache = null;
      __ctxCache = null;
    }

    if(!__rapmCache || !__ctxCache){
      const rapmUrl = `/api/rapm/player/${encodeURIComponent(playerId)}?season=${encodeURIComponent(season||'')}`;
      const ctxUrl = `/api/context/player/${encodeURIComponent(playerId)}?season=${encodeURIComponent(season||'')}`;
      const [rapmRes, ctxRes] = await Promise.all([fetch(rapmUrl), fetch(ctxUrl)]);
      __rapmCache = await rapmRes.json();
      __ctxCache = await ctxRes.json();
    }

    renderRAPMUI();
  }catch(e){
    rapmPanelInner.textContent = 'Error loading RAPM.';
  }
}

async function loadProjectionsPanel(){
  if(!projPanelInner) return;
  if(!projectionsEnabled()){
    projPanelInner.textContent = '';
    return;
  }
  const playerId = playerSelect?.value;
  const teamAbbrev = String(teamSelect?.value||'').toUpperCase();
  const season = seasonSelect?.value;
  try{
    const league = await ensureProjLeaguePlayers();
    
    // Fetch context data for all league players
    const contextPromises = league.map(async (p)=>{
      try{
        const r = await fetch(`/api/context/player/${encodeURIComponent(p.playerId)}?season=${encodeURIComponent(season||'')}`, { cache:'no-store' });
        const data = await r.json();
        if(!data?.error && Array.isArray(data.rows)){
          // Find the 5v5 row
          const row5v5 = data.rows.find(row => String(row.StrengthState||'') === '5v5');
          if(row5v5){
            const parseNum = (val) => {
              if(val == null) return null;
              // If already a number, return it
              if(typeof val === 'number') return Number.isFinite(val) ? val : null;
              // Parse string values
              const n = parseLocaleNumber(val);
              return Number.isFinite(n) ? n : null;
            };
            p.contextData = { 
              QoT: parseNum(row5v5.QoT_blend_xG67_G33), 
              QoC: parseNum(row5v5.QoC_blend_xG67_G33), 
              ZS: parseNum(row5v5.ZS_Difficulty) 
            };
          }
        }
      }catch(_){ /* ignore context fetch failures */ }
    });
    await Promise.all(contextPromises);

    const teamObj = teams.find(tm=>String(tm?.Team||tm?.team||'').toUpperCase() === teamAbbrev);
    const teamColor = teamObj?.Color || teamObj?.color || null;

    // Set CSS variable for team color highlight
    if(teamColor){
      const rgb = hexToRgb(teamColor);
      if(rgb){
        document.documentElement.style.setProperty('--league-highlight-color', `rgba(${rgb.r},${rgb.g},${rgb.b},0.15)`);
      }
    }

    renderLeagueTable(league, playerId);

    const p = league.find(x=>String(x.playerId) === String(playerId||''));
    const playerContext = p?.contextData || null;
    renderPlayerKpisFromLeague(p, playerContext);
    renderPlayerRadarFromLeague(p, league, playerContext, teamColor);

    renderTeamStackFromLeague(teamAbbrev, league, teamColor);
  }catch(e){
    if(projPlayerKpis) projPlayerKpis.innerHTML = '<div class="skater-empty" style="grid-column:1 / -1; padding:8px 2px;">Error loading projections.</div>';
  }
}

async function loadPlayers(){
  if(!teamSelect || !seasonSelect || !playerSelect) return;
  const team = teamSelect.value;
  const season = seasonSelect.value;
  if(!team || !season){
    playerSelect.innerHTML = '<option value="">Select team/season</option>';
    return;
  }
  playerSelect.disabled = true;
  playerSelect.innerHTML = '<option value="">Loading...</option>';
  try{
    const r = await fetch(`/api/skaters/players?team=${encodeURIComponent(team)}&season=${encodeURIComponent(season)}`);
    const data = await r.json();
    const list = Array.isArray(data?.players) ? data.players : [];
    list.sort((a,b)=> String(a.name||'').localeCompare(String(b.name||'')));
    const savedKey = `skaters_player_${team}`;
    const saved = localStorage.getItem(savedKey);
    playerSelect.innerHTML = '<option value="">Select player</option>' + list.map(p=>`<option value="${p.playerId}">${p.name}</option>`).join('');
    if(saved && list.some(p=>String(p.playerId)===saved)) playerSelect.value = saved;
  }catch(e){
    playerSelect.innerHTML = '<option value="">Error loading players</option>';
  }finally{
    playerSelect.disabled = false;
  }
}

async function loadPlayerCard(){
  if(!teamSelect || !seasonSelect || !playerSelect) return;
  const team = teamSelect.value;
  const season = seasonSelect.value;
  const playerId = playerSelect.value;
  if(!playerId){
    skaterName.textContent = 'Select a player';
    skaterInfo.innerHTML = '';
    setMsg('Choose Team, Season, and Player.');
    return;
  }
  localStorage.setItem(`skaters_player_${team}`, String(playerId));
  setHeadshot(team, season, playerId);
  setMsg('Loading player info...');
  try{
    const r = await fetch(`/api/player/${encodeURIComponent(playerId)}/landing`);
    const data = await r.json();
    if(data?.error){
      setMsg('Could not load player info.', true);
      skaterInfo.innerHTML = '';
      skaterName.textContent = 'Unknown player';
      return;
    }
    renderPlayerLanding(data);
    setMsg('');
    if(cardEnabled()) loadCardPanel();
    loadRAPMPanel();
    if(projectionsEnabled()) loadProjectionsPanel();
  }catch(e){
    setMsg('Could not load player info.', true);
  }
}

tabCard?.addEventListener('click', ()=> setActiveTab('card'));
tabRAPM?.addEventListener('click', ()=> setActiveTab('rapm'));
tabProjections?.addEventListener('click', ()=> setActiveTab('projections'));

cardSeasonState?.addEventListener('change', ()=> loadCardPanel());
cardMinGp?.addEventListener('change', ()=> loadCardPanel());
cardMinToi?.addEventListener('change', ()=> loadCardPanel());
cardStrengthState?.addEventListener('change', ()=> loadCardPanel());
cardRates?.addEventListener('change', ()=> loadCardPanel());
cardXgModel?.addEventListener('change', ()=> loadCardPanel());

btnConfigureCard?.addEventListener('click', async ()=>{
  await showCardConfig();
});
btnCloseCardConfig?.addEventListener('click', ()=> closeCardConfig());
cardConfigModal?.addEventListener('click', (e)=>{
  // click backdrop to close
  if(e?.target === cardConfigModal) closeCardConfig();
});
document.addEventListener('keydown', (e)=>{
  if(e?.key === 'Escape' && cardConfigModal && !cardConfigModal.hidden) closeCardConfig();
});
btnResetCardConfig?.addEventListener('click', async ()=>{
  const defs = await ensureCardDefs();
  __cardConfig = buildDefaultCardConfig(defs);
  renderCardConfigModal(defs, __cardConfig);
});
btnSaveCardConfig?.addEventListener('click', ()=>{
  if(__cardConfig){
    saveCardConfig(__cardConfig);
    closeCardConfig();
    loadCardPanel();
  }
});

btnExportCardConfig?.addEventListener('click', async ()=>{
  await exportCardConfig();
});

btnImportCardConfig?.addEventListener('click', async ()=>{
  // Prefer file import; if user cancels, fall back to paste.
  if(ccImportFile){
    try{ ccImportFile.value = ''; }catch(_){/*noop*/}
    ccImportFile.click();
    return;
  }
  const t = prompt('Paste card config JSON');
  if(t) await importCardConfigFromText(t);
});

ccImportFile?.addEventListener('change', async ()=>{
  const f = ccImportFile.files && ccImportFile.files[0];
  if(!f){
    const t = prompt('Paste card config JSON');
    if(t) await importCardConfigFromText(t);
    return;
  }
  try{
    const text = await f.text();
    await importCardConfigFromText(text);
  }catch(_){
    alert('Could not read file.');
  }
});

projTabPlayer?.addEventListener('click', ()=> setActiveProjSubtab('player'));
projTabTeam?.addEventListener('click', ()=> setActiveProjSubtab('team'));
projTabLeague?.addEventListener('click', ()=> setActiveProjSubtab('league'));
setActiveProjSubtab('player');

projExportCsv?.addEventListener('click', ()=>{
  if(!__projLeaguePlayers || !__projLeaguePlayers.length) return;
  const cols = ['name','team','position','gp','Age','Rookie','EVO','EVD','PP','SH','QoT','QoC','ZS','total'];
  const header = cols.join(',');
  const rows = __projLeaguePlayers.filter(p=>p.name && String(p.name).trim()).map(p=>{
    return cols.map(c=>{
      if(c === 'QoT' || c === 'QoC' || c === 'ZS'){
        const v = p.contextData?.[c];
        return v != null ? String(v) : '';
      }
      const v = p[c];
      return v != null ? String(v) : '';
    }).join(',');
  });
  const csv = header + '\n' + rows.join('\n');
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = 'projections_league.csv';
  link.click();
});

teamSelect?.addEventListener('change', async ()=>{
  await loadPlayers();
  await loadPlayerCard();
  applyRAPMSelectTextColor();
  applyExportButtonTextColor();
  if(projectionsEnabled()) loadProjectionsPanel();
});
seasonSelect?.addEventListener('change', async ()=>{
  updateTabsVisibility();
  await loadPlayers();
  await loadPlayerCard();
});
playerSelect?.addEventListener('change', ()=> loadPlayerCard());

setTimeout(async ()=>{ updateTabsVisibility();
  await loadPlayers();
  await loadPlayerCard();
  applyExportButtonTextColor();
}, 650);
</script>
{% endblock %}
