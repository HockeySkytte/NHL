{% extends 'base.html' %}

{% block extra_filters %}
<label>Player
  <select id="playerSelect"></select>
</label>
<label id="edgeSeasonStateWrap">Season State
  <select id="edgeSeasonState">
    <option value="regular" selected>Regular</option>
    <option value="playoffs">Playoffs</option>
  </select>
</label>
<label id="cardSeasonStateWrap">Season State
  <select id="cardSeasonState">
    <option value="regular" selected>Regular</option>
    <option value="playoffs">Playoffs</option>
    <option value="all">All</option>
  </select>
</label>
<label id="cardStrengthStateWrap">Strength State
  <select id="cardStrengthState">
    <option value="5v5" selected>5v5</option>
    <option value="PP">PP</option>
    <option value="SH">SH</option>
    <option value="Other">Other</option>
    <option value="all">All</option>
  </select>
</label>
<label id="cardRatesWrap">Totals / Rates
  <select id="cardRates">
    <option value="Totals" selected>Totals</option>
    <option value="Per60">Per 60</option>
    <option value="PerGame">Per Game</option>
  </select>
</label>
<label id="cardXgModelWrap">xG Model
  <select id="cardXgModel">
    <option value="xG_S">xG_S (Shots)</option>
    <option value="xG_F" selected>xG_F (Fenwick)</option>
    <option value="xG_F2">xG_F2 (Fenwick)</option>
  </select>
</label>
<label id="cardMinGpWrap">Min GP
  <input id="cardMinGp" type="number" min="0" step="1" placeholder="0" />
</label>
<label id="cardMinToiWrap">Min TOI
  <input id="cardMinToi" type="number" min="0" step="1" placeholder="0" />
</label>
<label id="cardScopeWrap">Scope
  <div id="cardScopeButtons" class="segmented" role="group" aria-label="Card scope">
    <button type="button" class="seg-btn active" data-scope="season">Season</button>
    <button type="button" class="seg-btn" data-scope="career">Career</button>
  </div>
  <input id="cardScope" type="hidden" value="season" />
</label>
{% endblock %}

{% block head %}
<style>
  .skater-wrap{ width:100%; margin-left:-10px; min-width:0; overflow-x:hidden; }
  .skater-card{ width:100%; box-sizing:border-box; background:rgba(255,255,255,0.02); border:1px solid #232a3a; border-radius:14px; padding:24px 26px 18px; min-width:0; overflow-x:hidden; }
  .skater-top{ display:flex; gap:22px; align-items:center; }
  .skater-img{ width:170px; height:170px; border-radius:18px; object-fit:cover; background:var(--panel); border:1px solid #2a3142; }
  .skater-name{ font-size:38px; font-weight:800; margin:0; letter-spacing:.2px; }
  .skater-sub{ margin-top:10px; color:var(--text-dim); font-size:16px; display:flex; gap:18px; flex-wrap:wrap; }
  .kv{ display:flex; gap:6px; align-items:baseline; }
  .k{ text-transform:uppercase; font-size:12px; letter-spacing:1px; color:var(--text-dim); font-weight:750; }
  .v{ font-weight:750; color:var(--text); }
  .skater-empty{ text-align:center; color:var(--text-dim); padding:30px 10px; }
  .err{ color:#ff8f8f; font-weight:650; }

  #cardMinGpWrap input, #cardMinToiWrap input{ width:94px; }

  .segmented{ display:flex; gap:8px; margin-top:6px; }
  .seg-btn{ flex:1; background:transparent; border:1px solid #2a3142; color:var(--text); padding:8px 10px; border-radius:10px; font-weight:750; letter-spacing:.2px; cursor:pointer; }
  .seg-btn.active{ outline:2px solid var(--accent); background:rgba(255,255,255,0.03); }

  .subtabs{ display:flex; gap:12px; align-items:center; margin-top:18px; }
  .subtab-btn{ background:transparent; border:1px solid #2a3142; color:var(--text); padding:8px 14px; border-radius:10px; font-weight:750; letter-spacing:.2px; cursor:pointer; }
  .subtab-btn.active{ outline:2px solid var(--accent); }
  .panel{ margin-top:14px; box-sizing:border-box; background:rgba(255,255,255,0.02); border:1px solid #232a3a; border-radius:14px; padding:16px 16px 12px; min-width:0; }
  .mini-table{ width:100%; border-collapse:collapse; font-size:14px; }
  .mini-table th{ text-align:left; font-size:12px; text-transform:uppercase; letter-spacing:.8px; padding:10px 8px; color:var(--text-dim); font-weight:800; border-bottom:1px solid #222b37; }
  .mini-table td{ padding:10px 8px; border-bottom:1px solid #1a2230; }

  #tabPanelCard.panel{ padding:10px 10px 8px; }
  .card-panel-hd{ display:flex; align-items:center; justify-content:space-between; gap:12px; padding:2px 2px 10px; }
  .card-panel-meta{ color:rgba(255,255,255,0.95); font-size:18px; font-style:italic; font-weight:800; letter-spacing:.2px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .card-grid{ display:grid; grid-template-columns: 1fr 1fr 1fr; gap:36px; width:100%; margin:0; }
  @media (max-width: 980px){ .card-grid{ grid-template-columns: 1fr; } }
  .card-col{ border:none; border-radius:0; padding:0; background:transparent; }
  .card-col h3{ margin:0 0 10px; font-size:18px; letter-spacing:.6px; text-transform:uppercase; color:rgba(255,255,255,0.98); font-weight:850; }
  .metric{ padding:2px 0 10px; border:none; border-radius:0; background:transparent; margin-bottom:10px; }
  .metric:last-child{ margin-bottom:0; }
  .metric-head{ display:flex; align-items:baseline; justify-content:space-between; gap:10px; }
  .metric-name{ font-size:12px; letter-spacing:.2px; text-transform:none; color:var(--text-dim); font-weight:850; }
  .metric-val{ font-variant-numeric: tabular-nums; font-weight:850; color:rgba(255,255,255,0.95); }
  .metric-bar{ position:relative; height:10px; border-radius:999px; background:transparent; border:1px solid rgba(255,255,255,0.16); overflow:hidden; margin-top:8px; }
  .metric-fill{ position:absolute; top:0; left:0; height:100%; border-radius:999px; width:0%; background:#f7f7f7; }

  .card-slot{ margin-bottom:14px; }
  .card-slot:last-child{ margin-bottom:0; }

  .config-btn{ background:var(--panel-alt); border:1px solid #2a3142; color:var(--value-text, var(--text)); padding:8px 12px; border-radius:10px; font-weight:750; cursor:pointer; font-size:13px; }
  .config-btn:hover{ background:color-mix(in srgb, var(--panel-alt) 70%, black); }

  .modal{ position:fixed; inset:0; background:rgba(0,0,0,0.55); display:flex; align-items:center; justify-content:center; z-index:2000; }
  .modal[hidden]{ display:none !important; }
  .modal-card{ width:min(1100px, calc(100vw - 28px)); max-height:calc(100vh - 28px); overflow:auto; background:#0f1522; border:1px solid #2a3142; border-radius:14px; box-shadow:0 18px 44px rgba(0,0,0,0.6); }
  .modal-hd{ display:flex; align-items:center; justify-content:space-between; gap:12px; padding:14px 16px; border-bottom:1px solid #232a3a; }
  .modal-title{ font-weight:900; letter-spacing:.2px; }
  .modal-bd{ padding:14px 16px; }
  .cc-grid{ display:grid; grid-template-columns: repeat(3, 1fr); gap:12px; }
  @media (max-width: 980px){ .cc-grid{ grid-template-columns:1fr; } }
  .cc-slot{ border:1px solid #232a3a; border-radius:12px; padding:12px; background:rgba(255,255,255,0.02); }
  .cc-slot .s{ font-size:11px; letter-spacing:.8px; text-transform:uppercase; color:var(--text-dim); font-weight:900; }
  .cc-slot .n{ margin-top:6px; font-weight:850; }
  .cc-help{ color:var(--text-dim); font-size:13px; margin-bottom:12px; }
  .cc-row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-bottom:10px; }
  .cc-row select{ min-width:240px; }
  .cc-cat{ border-top:1px solid #232a3a; padding-top:10px; margin-top:10px; }
  .cc-cat summary{ cursor:pointer; font-weight:850; }
  .cc-metrics{ margin-top:8px; display:grid; grid-template-columns: 1fr 1fr; gap:8px 12px; }
  @media (max-width: 980px){ .cc-metrics{ grid-template-columns:1fr; } }
  .cc-metrics .cc-metric{ display:flex; flex-direction:row; gap:8px; align-items:center; font-size:13px; color:rgba(255,255,255,0.92); text-transform:none; letter-spacing:0; font-weight:650; }
  .cc-metrics .cc-metric input[type="checkbox"]{ margin:0; flex:0 0 auto; }
  .cc-metrics .cc-metric span{ display:inline; }
  .modal-ft{ display:flex; gap:10px; justify-content:flex-end; padding:12px 16px; border-top:1px solid #232a3a; }
  .btn{ background:var(--panel-alt); border:1px solid #2a3142; color:var(--value-text, var(--text)); padding:8px 12px; border-radius:10px; font-weight:750; cursor:pointer; font-size:13px; }
  .btn:hover{ background:rgba(255,255,255,0.05); }
  .btn.primary{ outline:2px solid var(--accent); }

  .rapm-controls{ display:flex; flex-wrap:wrap; gap:14px; align-items:flex-end; margin-bottom:14px; }
  .rapm-controls label{ min-width:160px; }
  .rapm-controls select{ color:var(--value-text, var(--text)); }

  .rapm-split{ display:grid; grid-template-columns: 1.4fr 0.8fr 0.8fr; gap:14px; max-width:1150px; margin:0 auto; }
  .rapm-sect{ --rapmBarH: 340px; border:1px solid #232a3a; border-radius:12px; padding:12px 12px 10px; background:rgba(255,255,255,0.01); }
  .rapm-sect h3{ margin:0 0 10px; font-size:18px; letter-spacing:.6px; text-transform:uppercase; color:rgba(255,255,255,0.98); font-weight:850; }
  .toi{ margin-top:8px; font-size:12px; color:rgba(255,255,255,0.90); text-align:center; font-weight:750; }

  .charts-grid{ display:grid; grid-template-columns: 1fr 1fr; gap:14px; align-items:stretch; }
  @media (max-width: 1100px){ .charts-grid{ grid-template-columns:1fr; } }
  .chart-block{ border:1px solid #232a3a; border-radius:12px; padding:12px 12px 10px; background:rgba(255,255,255,0.01); display:flex; flex-direction:column; min-width:0; }
  .chart-hd{ display:flex; flex-direction:column; align-items:stretch; gap:10px; margin-bottom:10px; }
  .chart-hd h3{ margin:0; font-size:18px; letter-spacing:.6px; text-transform:uppercase; color:rgba(255,255,255,0.98); font-weight:850; }
  .chart-controls{ width:100%; display:grid; grid-template-columns: 1fr 1fr; gap:12px; align-items:flex-end; }
  @media (max-width: 640px){ .chart-controls{ grid-template-columns:1fr; } }
  .chart-controls label{ min-width:0; }
  .chart-controls select{ width:100%; }
  .charts-toolbar{ display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap; margin-bottom:10px; }
  .charts-sub{ color:var(--text-dim); font-size:13px; }
  .chart-area{ position:relative; width:100%; height:520px; flex:1 1 auto; }
  @media (max-width: 980px){ .chart-area{ height:420px; } }
  .chart-canvas{ width:100% !important; height:100% !important; display:block; }

  .rapm-row{ display:flex; gap:3px; align-items:flex-start; justify-content:center; }
  .rapm-axis{ width:40px; height:var(--rapmBarH); position:relative; }
  .rapm-axis .lbl{ position:absolute; left:0; font-size:11px; color:var(--text-dim); }
  .rapm-axis .top{ top:0; }
  .rapm-axis .mid{ transform:translateY(-50%); }
  .rapm-axis .bot{ bottom:0; }

  .bars{ display:flex; gap:12px; align-items:flex-end; justify-content:center; flex:0; }
  .bar-col{ width:112px; }
  .bar-label{ text-align:center; font-size:12px; color:var(--text-dim); margin-top:8px; }
  .bar-value{ text-align:center; font-size:12px; font-weight:750; margin-top:6px; }
  .bar-area{ position:relative; height:var(--rapmBarH); border-radius:10px; background:rgba(255,255,255,0.02); border:1px solid #1f2734; overflow:hidden; }
  .bar-line{ position:absolute; left:0; right:0; height:1px; background:#273246; }
  .bar{ position:absolute; left:14%; width:72%; border-radius:8px; background:var(--accent); opacity:1; }
  .bar.neg{ background:#ff6a6a; opacity:1; }

  .rapm-career{ max-width:1150px; margin:0 auto; }
  .rapm-career .career-area{ width:100%; flex:1; min-width:0; }
  .rapm-career svg{ position:absolute; inset:0; width:100%; height:100%; }
  .rapm-career-legend{ display:flex; gap:22px; align-items:center; justify-content:center; margin-top:10px; color:rgba(255,255,255,0.90); font-size:14px; letter-spacing:.2px; font-weight:750; }
  .rapm-career-legend .sw{ width:12px; height:12px; border-radius:3px; display:inline-block; margin-right:8px; }
  .rapm-tooltip{ position:absolute; z-index:20; pointer-events:none; background:rgba(15,21,34,0.96); border:1px solid #2a3142; border-radius:10px; padding:10px 12px; box-shadow:0 10px 26px rgba(0,0,0,0.45); min-width:170px; display:none; }
  .rapm-tooltip .t-title{ font-weight:850; font-size:13px; color:rgba(255,255,255,0.95); margin-bottom:6px; letter-spacing:.2px; }
  .rapm-tooltip .t-row{ display:flex; align-items:center; justify-content:space-between; gap:12px; font-size:12px; color:rgba(255,255,255,0.86); }
  .rapm-tooltip .dot{ width:8px; height:8px; border-radius:50%; display:inline-block; margin-right:8px; flex:0 0 auto; }
  .rapm-tooltip .lbl{ display:flex; align-items:center; min-width:0; }
  .rapm-tooltip .val{ font-variant-numeric:tabular-nums; font-weight:800; }

  .proj-subtabs{ display:flex; gap:12px; align-items:center; margin-top:6px; }
  .proj-subtab-btn{ background:transparent; border:1px solid #2a3142; color:var(--text); padding:8px 14px; border-radius:10px; font-weight:750; letter-spacing:.2px; cursor:pointer; }
  .proj-subtab-btn.active{ outline:2px solid var(--accent); }
  .proj-subpanel{ margin-top:14px; background:rgba(0,0,0,.18); border:1px solid #232a3a; border-radius:12px; padding:16px; }
  .proj-subpanel[hidden]{ display:none !important; }
  .proj-grid{ display:grid; grid-template-columns: 320px 1fr; gap:16px; align-items:start; }
  .kpi-card{ background:rgba(0,0,0,.12); border:1px solid #2a3142; border-radius:12px; padding:12px 12px; text-align:center; }
  .kpi-title{ font-size:11px; letter-spacing:.8px; text-transform:uppercase; color:var(--text-dim); font-weight:850; }
  .kpi-value{ margin-top:6px; font-size:18px; font-weight:850; color:var(--text); font-variant-numeric: tabular-nums; }
  .kpi-list{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
  .proj-canvas{ width:100%; height:360px; }
  #projPlayerRadar{ height:500px; }
  #projTeamStack{ height:600px; }
  .proj-table-wrap{ overflow:auto; border:1px solid #232a3a; border-radius:12px; }
  .proj-export-wrap{ display:flex; justify-content:flex-end; margin-bottom:12px; }
  .proj-export-btn{ background:var(--panel-alt); border:1px solid #2a3142; color:var(--value-text, var(--text)); padding:8px 14px; border-radius:8px; font-weight:650; cursor:pointer; font-size:13px; }
  .proj-export-btn:hover{ background:rgba(255,255,255,0.05); }
  .proj-table{ width:100%; border-collapse:collapse; font-size:14px; }
  .proj-table th{ position:sticky; top:0; background:#0f1522; text-align:left; font-size:12px; text-transform:uppercase; letter-spacing:.8px; padding:10px 8px; color:var(--text-dim); font-weight:800; border-bottom:1px solid #222b37; cursor:pointer; user-select:none; }
  .proj-table td{ padding:10px 8px; border-bottom:1px solid #1a2230; white-space:nowrap; text-align:center; }
  .proj-table td.name{ text-align:left; }
  .proj-table th.name{ text-align:left; }
  .proj-table td.num, .proj-table th.num{ text-align:center; }
  .proj-table tr.selected-player{ background:var(--league-highlight-color, rgba(77,163,255,0.12)); }
  .sort-ind{ color:rgba(255,255,255,0.6); font-weight:900; margin-left:6px; }

  .edge-grid{ display:grid; grid-template-columns: 1fr 1fr; gap:16px; align-items:start; }
  .edge-card{ background:rgba(0,0,0,.18); border:1px solid #232a3a; border-radius:12px; padding:14px; }
  .edge-title{ font-size:12px; letter-spacing:.8px; text-transform:uppercase; color:var(--text-dim); font-weight:850; margin:0 0 10px 0; }
  .edge-controls{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px; }
  .edge-control{ display:flex; align-items:center; gap:8px; }
  .edge-control label{ font-size:12px; color:var(--text-dim); font-weight:800; letter-spacing:.4px; text-transform:uppercase; }
  .edge-select{ background:var(--panel-alt); border:1px solid #2a3142; color:var(--value-text, var(--text)); padding:8px 10px; border-radius:10px; font-weight:750; }

  .edge-zone-rink{ position:relative; width:100%; max-width:520px; margin:10px auto 2px; }
  .edge-zone-rink img{ width:100%; height:auto; display:block; border-radius:14px; filter: saturate(0.92) contrast(1.05); opacity:0.95; }
  .edge-zone-kpi-row{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; gap:12px; padding:0 16px; }
  .edge-zone-kpi{ position:static; transform:none; flex:1 1 0; max-width:170px; min-width:0; background:rgba(7,10,16,0.78); border:1px solid rgba(255,255,255,0.14); border-radius:14px; padding:10px 10px; text-align:center; box-shadow: 0 10px 28px rgba(0,0,0,0.35); }
  .edge-zone-pill{ display:inline-block; padding:5px 12px; border-radius:10px; border:1px solid rgba(255,255,255,0.25); background:rgba(15,21,34,0.92); font-weight:900; font-size:14px; letter-spacing:.2px; margin-bottom:10px; }
  .edge-zone-value{ font-size:30px; font-weight:950; line-height:1.0; font-variant-numeric:tabular-nums; margin:0 0 6px 0; color:#ffffff; }
  .edge-zone-avg{ font-size:12px; font-weight:850; letter-spacing:.4px; color:rgba(255,255,255,0.72); margin:0 0 6px 0; }
  .edge-zone-label{ font-size:12px; font-weight:900; letter-spacing:.8px; text-transform:uppercase; color:rgba(255,255,255,0.82); }
  @media (max-width: 560px){
    .edge-zone-kpi-row{ flex-direction:column; justify-content:center; gap:10px; padding:12px; }
    .edge-zone-kpi{ width:86%; max-width:260px; padding:8px 8px; }
    .edge-zone-value{ font-size:24px; }
    .edge-zone-pill{ font-size:13px; padding:4px 10px; }
  }

  @media (max-width: 980px){
    .edge-grid{ grid-template-columns: 1fr; }
  }

  .table-wrap{ width:100%; max-width:100%; max-height:70vh; min-width:0; overflow-x:auto; overflow-y:auto; border:1px solid #232a3a; border-radius:12px; }
  #tabPanelTable{ min-width:0; }
  #tablePanelInner{ min-width:0; }
  .metrics-table{ width:max-content; min-width:100%; border-collapse:separate; border-spacing:0; font-size:14px; table-layout:auto; }
  .metrics-table th{ position:sticky; top:0; background:#0f1522; text-align:center; font-size:12px; text-transform:uppercase; letter-spacing:.8px; padding:10px 12px; color:var(--text-dim); font-weight:900; border-bottom:1px solid #222b37; user-select:none; white-space:nowrap; z-index:2; }
  .metrics-table td{ padding:10px 12px; border-bottom:1px solid #1a2230; white-space:nowrap; text-align:center; font-variant-numeric: tabular-nums; }
  .metrics-table th, .metrics-table td{ min-width:92px; }
  .metrics-table td.name, .metrics-table th.name{ text-align:left; }
  .metrics-table td.rank, .metrics-table th.rank{ text-align:left; }
  .metrics-table td.rank, .metrics-table th.rank{ width:64px; min-width:64px; max-width:64px; }
  .metrics-table td.rank, .metrics-table td.name{ position:sticky; background:#0f1522; z-index:1; }
  .metrics-table td.rank{ left:0; border-right:2px solid #1a2230; }
  .metrics-table td.name{ left:64px; width:180px; min-width:180px; max-width:180px; }
  .metrics-table th.rank, .metrics-table th.name{ position:sticky; background:#0f1522; z-index:4; }
  .metrics-table th.rank{ left:0; border-right:2px solid #222b37; }
  .metrics-table th.name{ left:64px; width:180px; min-width:180px; max-width:180px; }
  .metrics-table tbody tr:hover{ background:rgba(255,255,255,0.04); }
  .metrics-table th[data-mid]{ cursor:pointer; user-select:none; }
  .metrics-table th[data-mid]:hover{ background:#141a28; }

  .table-metric-picker{ display:grid; grid-template-columns: repeat(3, 1fr); gap:12px; }
  @media (max-width: 980px){ .table-metric-picker{ grid-template-columns:1fr; } }
  .table-metric-group{ border:1px solid #232a3a; border-radius:12px; padding:12px; background:rgba(255,255,255,0.02); }
  .table-metric-group .t{ font-size:11px; letter-spacing:.8px; text-transform:uppercase; color:var(--text-dim); font-weight:900; margin-bottom:10px; }
  .table-metrics-grid{ display:grid; grid-template-columns: 1fr 1fr; gap:8px 12px; }
  .table-metric{ display:flex; flex-direction:row; gap:8px; align-items:center; font-size:13px; color:rgba(255,255,255,0.92); padding:0; }
  .table-metric input{ margin:0; flex:0 0 auto; cursor:pointer; }
  .table-metric span{ cursor:pointer; flex:1 1 auto; }
</style>
{% endblock %}

{% block content %}
<div class="skater-wrap">
  <div class="skater-card">
    <div class="skater-top">
      <img id="skaterImg" class="skater-img" alt="Player" />
      <div style="min-width:0;">
        <h2 id="skaterName" class="skater-name">Select a player</h2>
        <div id="skaterInfo" class="skater-sub"></div>
      </div>
    </div>

    <div class="subtabs" role="tablist" aria-label="Skater tabs">
      <button id="tabCard" class="subtab-btn active" type="button" role="tab" aria-selected="true">Card</button>
      <button id="tabCharts" class="subtab-btn" type="button" role="tab" aria-selected="false">Charts</button>
      <button id="tabEdge" class="subtab-btn" type="button" role="tab" aria-selected="false">Edge</button>
      <button id="tabRAPM" class="subtab-btn" type="button" role="tab" aria-selected="false">RAPM</button>
      <button id="tabProjections" class="subtab-btn" type="button" role="tab" aria-selected="false">Projections</button>
      <button id="tabTable" class="subtab-btn" type="button" role="tab" aria-selected="false">Table View</button>
    </div>

    <div id="tabPanelCard" class="panel" role="tabpanel">
      <div class="card-panel-hd">
        <div id="cardSlicerSummary" class="card-panel-meta"></div>
        <button id="btnConfigureCard" class="config-btn" type="button">Configure Card</button>
      </div>
      <div id="cardPanelInner" class="skater-empty">Select a player to view Card.</div>
    </div>

    <div id="tabPanelTable" class="panel" role="tabpanel" style="display:none;">
      <div class="card-panel-hd" style="padding-bottom: 8px;">
        <div id="tableSlicerSummary" class="card-panel-meta"></div>
        <div style="display:flex; gap:10px; align-items:center;">
          <button id="btnConfigureTable" class="config-btn" type="button">Configure Table</button>
          <button id="btnReloadTable" class="config-btn" type="button">Reload</button>
          <button id="btnExportTableCsv" class="config-btn" type="button">Export CSV</button>
        </div>
      </div>
      <div id="tablePanelInner">
        <div id="tableLoading" class="skater-empty" style="display:none; padding:10px 0;">Loading table...</div>
        <div id="tableError" class="skater-empty err" style="display:none; padding:10px 0;"></div>
        <div class="table-wrap">
          <table id="skatersTable" class="metrics-table"></table>
        </div>
      </div>
    </div>

    <div id="tabPanelCharts" class="panel" role="tabpanel" style="display:none;">
      <div class="charts-toolbar">
        <div id="chartsSlicerSummary" class="card-panel-meta"></div>
        <div id="chartsHighlightWrap">
          <div id="chartsHighlightButtons" class="segmented" role="group" aria-label="Charts highlight">
            <button id="chartsHlPlayer" type="button" class="seg-btn" aria-pressed="false">Highlight Player</button>
            <button id="chartsHlTeam" type="button" class="seg-btn active" aria-pressed="true">Highlight Team</button>
          </div>
        </div>
      </div>

      <div id="chartsEmpty" class="skater-empty" hidden>Select a season to view Charts.</div>

      <div id="chartsGrid" class="charts-grid">
        <section class="chart-block" aria-label="Play Driving chart">
          <div class="chart-hd">
            <h3>Play Driving</h3>
            <div class="chart-controls">
              <label>X Axis
                <select id="pdX"></select>
              </label>
              <label>Y Axis
                <select id="pdY"></select>
              </label>
            </div>
          </div>
          <div class="chart-area">
            <canvas id="pdChart" class="chart-canvas"></canvas>
          </div>
        </section>

        <section class="chart-block" aria-label="Shooting and Context chart">
          <div class="chart-hd">
            <h3>Shooting and Context</h3>
            <div class="chart-controls">
              <label>X Axis
                <select id="scX"></select>
              </label>
              <label>Y Axis
                <select id="scY"></select>
              </label>
            </div>
          </div>
          <div class="chart-area">
            <canvas id="scChart" class="chart-canvas"></canvas>
          </div>
        </section>
      </div>
    </div>

    <div id="tabPanelEdge" class="panel" role="tabpanel" style="display:none;">
      <div id="edgePanelInner" class="skater-empty">Select a player to view Edge metrics.</div>
    </div>

    <div id="tabPanelRAPM" class="panel" role="tabpanel" style="display:none;">
      <div id="rapmPanelInner" class="skater-empty">Select a player to view RAPM.</div>
    </div>
    <div id="tabPanelProjections" class="panel" role="tabpanel" style="display:none;">
      <div id="projPanelInner">
        <div class="proj-subtabs" role="tablist" aria-label="Skater projections tabs">
          <button id="projTabPlayer" class="proj-subtab-btn active" type="button" role="tab" aria-selected="true">Player</button>
          <button id="projTabTeam" class="proj-subtab-btn" type="button" role="tab" aria-selected="false">Team</button>
          <button id="projTabLeague" class="proj-subtab-btn" type="button" role="tab" aria-selected="false">League</button>
        </div>

        <section id="projPanelPlayer" class="proj-subpanel" role="tabpanel">
          <div class="proj-grid">
            <div id="projPlayerKpis" class="kpi-list"></div>
            <div style="min-width:0;">
              <canvas id="projPlayerRadar" class="proj-canvas"></canvas>
            </div>
          </div>
        </section>

        <section id="projPanelTeam" class="proj-subpanel" role="tabpanel" hidden>
          <canvas id="projTeamStack" class="proj-canvas"></canvas>
        </section>

        <section id="projPanelLeague" class="proj-subpanel" role="tabpanel" hidden>
          <div class="proj-export-wrap">
            <button id="projExportCsv" class="proj-export-btn">Export CSV</button>
          </div>
          <div class="proj-table-wrap">
            <table id="projLeagueTable" class="proj-table"></table>
          </div>
        </section>
      </div>
    </div>

    <div id="skaterMsg" class="skater-empty" style="margin-top:10px;">Choose Team, Season, and Player.</div>
  </div>
</div>

<div id="cardConfigModal" class="modal" hidden>
  <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="cardConfigTitle">
    <div class="modal-hd">
      <div id="cardConfigTitle" class="modal-title">Configure Card</div>
      <button id="btnCloseCardConfig" class="btn" type="button">Close</button>
    </div>
    <div class="modal-bd">
      <div class="cc-help">Choose a category and metrics in each slot.</div>
      <div id="ccGrid" class="cc-grid"></div>
    </div>
    <div class="modal-ft">
      <input id="ccImportFile" type="file" accept="application/json" style="display:none;" />
      <button id="btnExportCardConfig" class="btn" type="button">Export</button>
      <button id="btnImportCardConfig" class="btn" type="button">Import</button>
      <button id="btnResetCardConfig" class="btn" type="button">Reset defaults</button>
      <button id="btnSaveCardConfig" class="btn primary" type="button">Save</button>
    </div>
  </div>
</div>

<div id="tableConfigModal" class="modal" hidden>
  <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="tableConfigTitle">
    <div class="modal-hd">
      <div id="tableConfigTitle" class="modal-title">Configure Table</div>
      <button id="btnCloseTableConfig" class="btn" type="button">Close</button>
    </div>
    <div class="modal-bd">
      <div class="cc-help">Select metrics (columns). Rank / Name / Pos are always included. Edge metrics are excluded for performance. Click column headers to sort.</div>
      <div class="cc-row" style="justify-content:flex-start; gap:10px;">
        <button id="btnTableDefaults" class="btn" type="button">Defaults</button>
        <button id="btnTableNone" class="btn" type="button">None</button>
        <button id="btnTableCardDefaults" class="btn" type="button">Card Defaults</button>
      </div>
      <div id="tableMetricPicker" class="table-metric-picker"></div>
    </div>
    <div class="modal-ft">
      <div id="tableConfigStatus" class="cc-help" style="margin:0; padding:0;"></div>
      <button id="btnApplyTableConfig" class="btn primary" type="button">Apply</button>
    </div>
  </div>
</div>

<script id="teams-data" type="application/json">{{ teams|tojson|safe }}</script>
{% endblock %}

{% block scripts %}
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script>
const DEFAULT_SKATER_IMG = 'https://assets.nhle.com/mugs/nhl/default-skater.png';

const teamSelect = document.getElementById('teamSelect');
const seasonSelect = document.getElementById('seasonSelect');
const playerSelect = document.getElementById('playerSelect');

const skaterImg = document.getElementById('skaterImg');
const skaterName = document.getElementById('skaterName');
const skaterInfo = document.getElementById('skaterInfo');
const skaterMsg = document.getElementById('skaterMsg');

const tabCard = document.getElementById('tabCard');
const tabTable = document.getElementById('tabTable');
const tabCharts = document.getElementById('tabCharts');
const tabEdge = document.getElementById('tabEdge');
const tabRAPM = document.getElementById('tabRAPM');
const tabProjections = document.getElementById('tabProjections');
const tabPanelCard = document.getElementById('tabPanelCard');
const tabPanelTable = document.getElementById('tabPanelTable');
const tabPanelCharts = document.getElementById('tabPanelCharts');
const tabPanelEdge = document.getElementById('tabPanelEdge');
const tabPanelRAPM = document.getElementById('tabPanelRAPM');
const tabPanelProjections = document.getElementById('tabPanelProjections');
const cardPanelInner = document.getElementById('cardPanelInner');
const chartsEmpty = document.getElementById('chartsEmpty');
const chartsGrid = document.getElementById('chartsGrid');
const chartsHighlightButtons = document.getElementById('chartsHighlightButtons');
const chartsHlPlayer = document.getElementById('chartsHlPlayer');
const chartsHlTeam = document.getElementById('chartsHlTeam');
const pdX = document.getElementById('pdX');
const pdY = document.getElementById('pdY');
const scX = document.getElementById('scX');
const scY = document.getElementById('scY');
const pdChartEl = document.getElementById('pdChart');
const scChartEl = document.getElementById('scChart');
const edgePanelInner = document.getElementById('edgePanelInner');
const rapmPanelInner = document.getElementById('rapmPanelInner');
const projPanelInner = document.getElementById('projPanelInner');
const cardSlicerSummary = document.getElementById('cardSlicerSummary');
const chartsSlicerSummary = document.getElementById('chartsSlicerSummary');

const cardScope = document.getElementById('cardScope');
const cardScopeButtons = document.getElementById('cardScopeButtons');
const cardSeasonState = document.getElementById('cardSeasonState');
const edgeSeasonState = document.getElementById('edgeSeasonState');
const cardMinGp = document.getElementById('cardMinGp');
const cardMinToi = document.getElementById('cardMinToi');
const cardStrengthState = document.getElementById('cardStrengthState');
const cardRates = document.getElementById('cardRates');
const cardXgModel = document.getElementById('cardXgModel');

const btnConfigureCard = document.getElementById('btnConfigureCard');
const cardConfigModal = document.getElementById('cardConfigModal');
const btnCloseCardConfig = document.getElementById('btnCloseCardConfig');
const btnResetCardConfig = document.getElementById('btnResetCardConfig');
const btnSaveCardConfig = document.getElementById('btnSaveCardConfig');
const btnExportCardConfig = document.getElementById('btnExportCardConfig');
const btnImportCardConfig = document.getElementById('btnImportCardConfig');
const ccImportFile = document.getElementById('ccImportFile');
const ccGrid = document.getElementById('ccGrid');

const cardScopeWrap = document.getElementById('cardScopeWrap');
const cardSeasonStateWrap = document.getElementById('cardSeasonStateWrap');
const edgeSeasonStateWrap = document.getElementById('edgeSeasonStateWrap');
const cardMinGpWrap = document.getElementById('cardMinGpWrap');
const cardMinToiWrap = document.getElementById('cardMinToiWrap');
const cardStrengthStateWrap = document.getElementById('cardStrengthStateWrap');
const cardRatesWrap = document.getElementById('cardRatesWrap');
const cardXgModelWrap = document.getElementById('cardXgModelWrap');

let __cardDefs = null;
let __cardConfig = null;
const CARD_CONFIG_KEY = 'nhlSkatersCardConfig_v1';
const CARD_SLOTS = ['L1','C1','R1','L2','C2','R2','L3','C3','R3'];

const SKATERS_STATE_KEY = 'nhlSkatersPageState_v1';
let __restoreActiveTab = null;
let __restorePlayerId = null;
let __restoreChartAxes = null;
let __restoreProjSubtab = null;
let __isRestoringSkatersState = false;
let __isBootingSkatersPage = true;

const projTabPlayer = document.getElementById('projTabPlayer');
const projTabTeam = document.getElementById('projTabTeam');
const projTabLeague = document.getElementById('projTabLeague');
const projPanelPlayer = document.getElementById('projPanelPlayer');
const projPanelTeam = document.getElementById('projPanelTeam');
const projPanelLeague = document.getElementById('projPanelLeague');
const projPlayerKpis = document.getElementById('projPlayerKpis');
const projLeagueTable = document.getElementById('projLeagueTable');
const projExportCsv = document.getElementById('projExportCsv');

const tableSlicerSummary = document.getElementById('tableSlicerSummary');
const btnConfigureTable = document.getElementById('btnConfigureTable');
const btnReloadTable = document.getElementById('btnReloadTable');
const btnExportTableCsv = document.getElementById('btnExportTableCsv');
const tableLoading = document.getElementById('tableLoading');
const tableError = document.getElementById('tableError');
const skatersTable = document.getElementById('skatersTable');

const tableConfigModal = document.getElementById('tableConfigModal');
const btnCloseTableConfig = document.getElementById('btnCloseTableConfig');
const btnApplyTableConfig = document.getElementById('btnApplyTableConfig');
const btnTableDefaults = document.getElementById('btnTableDefaults');
const btnTableNone = document.getElementById('btnTableNone');
const btnTableCardDefaults = document.getElementById('btnTableCardDefaults');
const tableSortMetric = document.getElementById('tableSortMetric');
const tableSortDir = document.getElementById('tableSortDir');
const tableMetricPicker = document.getElementById('tableMetricPicker');
const tableConfigStatus = document.getElementById('tableConfigStatus');

let __projLeaguePlayers = null;
let __projRadarChart = null;
let __projTeamChart = null;
let __projLeagueSort = { key: 'total', dir: 'desc' };

let __rapmCache = null;
let __ctxCache = null;
let __rapmKey = '';
let __scaleCache = null;
let __scaleKey = '';

let __edgeCache = null;
let __edgeKey = '';
let __edgeData = null;
let __edgeStrength = 'all';

let __pdChart = null;
let __scChart = null;
let __chartsHighlightMode = 'team'; // 'team' | 'player'
let __scatterCache = new Map();
let __logoImgCache = new Map();
let __chartsLastKey = '';
let __playerMugCache = new Map();

const teams = JSON.parse(document.getElementById('teams-data').textContent);

function teamLogoUrl(abbrev){
  const a = String(abbrev||'').toUpperCase();
  // Use same-origin proxy for SVG logos so canvas rendering works reliably.
  return a ? `/api/team-logo/${encodeURIComponent(a)}.svg` : '';
}

function getTeamLogoImage(abbrev, onLoad){
  const a = String(abbrev||'').toUpperCase();
  if(!a) return null;

  if(__logoImgCache.has(a)) return __logoImgCache.get(a);
  const url = teamLogoUrl(a);
  if(!url) return null;
  const img = new Image();
  img.onload = ()=>{
    try{ __pdChart && __pdChart.update('none'); }catch(_){/*noop*/}
    try{ __scChart && __scChart.update('none'); }catch(_){/*noop*/}
  };
  img.onerror = ()=>{ /* noop */ };
  img.src = url;
  __logoImgCache.set(a, img);
  return img;
}

function getPlayerMugImage(season, team, playerId){
  const pid = String(playerId||'').trim();
  if(!pid) return null;
  if(__playerMugCache.has(pid)) return __playerMugCache.get(pid);

  const s = String(season||'').trim();
  const t = String(team||'').trim();
  const primary = (s && t)
    ? `https://assets.nhle.com/mugs/nhl/${encodeURIComponent(s)}/${encodeURIComponent(t)}/${encodeURIComponent(pid)}.png`
    : null;
  const fallback = `https://assets.nhle.com/mugs/nhl/latest/${encodeURIComponent(pid)}.png`;

  const img = new Image();
  img.onload = ()=>{
    try{ __pdChart && __pdChart.update('none'); }catch(_){/*noop*/}
    try{ __scChart && __scChart.update('none'); }catch(_){/*noop*/}
  };
  img.onerror = ()=>{
    // one-time fallback
    if(img.dataset.fallbackDone === '1') return;
    img.dataset.fallbackDone = '1';
    img.src = fallback;
  };
  img.dataset.fallbackDone = '0';
  img.src = primary || fallback;
  __playerMugCache.set(pid, img);
  return img;
}

const PLAY_DRIVING_METRICS = [
  { id:'Play Driving|CF', label:'CF' },
  { id:'Play Driving|CA', label:'CA' },
  { id:'Play Driving|CF%', label:'CF%' },
  { id:'Play Driving|C+/-', label:'C+/-' },
  { id:'Play Driving|GF', label:'GF' },
  { id:'Play Driving|GA', label:'GA' },
  { id:'Play Driving|GF%', label:'GF%' },
  { id:'Play Driving|G+/-', label:'G+/-' },
  { id:'Play Driving|xGF', label:'xGF' },
  { id:'Play Driving|xGA', label:'xGA' },
  { id:'Play Driving|xGF%', label:'xGF%' },
  { id:'Play Driving|xG+/-', label:'xG+/-' },
  { id:'Play Driving|RAPM CF', label:'RAPM CF' },
  { id:'Play Driving|RAPM CA', label:'RAPM CA' },
  { id:'Play Driving|RAPM C+/-', label:'RAPM C+/-' },
  { id:'Play Driving|RAPM GF', label:'RAPM GF' },
  { id:'Play Driving|RAPM GA', label:'RAPM GA' },
  { id:'Play Driving|RAPM G+/-', label:'RAPM G+/-' },
  { id:'Play Driving|RAPM xGF', label:'RAPM xGF' },
  { id:'Play Driving|RAPM xGA', label:'RAPM xGA' },
  { id:'Play Driving|RAPM xG+/-', label:'RAPM xG+/-' },
];

const SHOOTING_CONTEXT_METRICS = [
  { id:'Shooting|iShots or iFenwick', label:'Individual Shots/Fenwick' },
  { id:'Shooting|ixG', label:'Individual xG' },
  { id:'Production|iGoals', label:'Individual Goals' },
  { id:'Shooting|Sh% or FSh%', label:'Individual Sh%' },
  { id:'Shooting|xSh% or xFSh%', label:'Individual xSh%' },
  { id:'Shooting|dSh% or dFSh%', label:'Individual dSh%' },
  { id:'Shooting|GAx', label:'Individual GAx' },
  { id:'Context|Sh%', label:'On-ice Sh%' },
  { id:'Context|Sv%', label:'On-ice Sv%' },
  { id:'Context|PDO', label:'PDO' },
  { id:'Context|GAx', label:'On-ice GAx' },
  { id:'Context|GSAx', label:'GSAx' },
  { id:'Context|QoT', label:'QoT' },
  { id:'Context|QoC', label:'QoC' },
  { id:'Context|ZS', label:'ZS' },
];

function metricLabel(metricId){
  const ratesVal = String(cardRates?.value || 'Totals');
  const xgVal = String(cardXgModel?.value || 'xG_F');
  const raw = String(metricId||'');
  const parts = raw.split('|');
  const cat = (parts.length > 1) ? String(parts[0]||'') : '';
  const m = String(parts[1]||parts[0]||'');

  const isPercent = m.includes('%') || m === 'PDO' || m === 'Sv%' || m === 'Sh%';
  const isRateLike = !isPercent && !['GP','TOI','QoT','QoC','ZS'].includes(m) && !m.startsWith('RAPM ');

  let base = m;
  if(m === 'iShots or iFenwick') base = (xgVal === 'xG_S') ? 'iShots' : 'iFenwick';
  if(m === 'Sh% or FSh%') base = (xgVal === 'xG_S') ? 'Sh%' : 'FSh%';
  if(m === 'xSh% or xFS%' || m === 'xSh% or xFSh%') base = (xgVal === 'xG_S') ? 'xSh%' : 'xFSh%';
  if(m === 'dSh% or dFSh%') base = (xgVal === 'xG_S') ? 'dSh%' : 'dFSh%';

  // Clarify which metrics are individual vs on-ice in Charts.
  if(cat === 'Shooting'){
    if(m === 'iShots or iFenwick') base = (xgVal === 'xG_S') ? 'Individual Shots' : 'Individual Fenwick';
    else if(m === 'ixG') base = 'Individual xG';
    else if(m === 'GAx') base = 'Individual GAx';
    else if(base === 'Sh%' || base === 'FSh%') base = `Individual ${base}`;
    else if(base === 'xSh%' || base === 'xFSh%' || base === 'xFS%') base = `Individual ${base}`;
    else if(base === 'dSh%' || base === 'dFSh%') base = `Individual ${base}`;
  }
  if(cat === 'Production'){
    if(m === 'iGoals') base = 'Individual Goals';
  }
  if(cat === 'Context'){
    if(base === 'Sh%' || base === 'Sv%' || base === 'PDO' || base === 'GAx' || base === 'GSAx') base = `On-ice ${base}`;
  }

  if(m.startsWith('RAPM ')){
    if(ratesVal === 'Totals') return base;
    return `${base}/60`;
  }
  if(isRateLike){
    if(ratesVal === 'Per60') return `${base}/60`;
    if(ratesVal === 'PerGame') return `${base}/GP`;
  }
  return base;
}

function metricBase(metricId){
  const xgVal = String(cardXgModel?.value || 'xG_F');
  const raw = String(metricId||'');
  const parts = raw.split('|');
  const m = String(parts[1]||parts[0]||'');

  let base = m;
  if(m === 'iShots or iFenwick') base = (xgVal === 'xG_S') ? 'iShots' : 'iFenwick';
  if(m === 'Sh% or FSh%') base = (xgVal === 'xG_S') ? 'Sh%' : 'FSh%';
  if(m === 'xSh% or xFS%' || m === 'xSh% or xFSh%') base = (xgVal === 'xG_S') ? 'xSh%' : 'xFSh%';
  if(m === 'dSh% or dFSh%') base = (xgVal === 'xG_S') ? 'dSh%' : 'dFSh%';
  if(m === 'GAx') base = 'GAx';
  return base;
}

function isAgainstMetric(metricId){
  const b = String(metricBase(metricId)||'');
  if(!b) return false;
  // “Against” metrics should be inverted so Good is top-right.
  if(b === 'CA' || b === 'GA' || b === 'xGA') return true;
  if(b === 'RAPM CA' || b === 'RAPM xGA') return true;
  return false;
}

function fillMetricSelect(sel, items, defaultId){
  if(!sel) return;
  const curr = String(sel.value||'');
  const desired = defaultId && !curr ? String(defaultId) : curr;
  sel.innerHTML = items.map(it=>{
    const lab = metricLabel(it.id);
    return `<option value="${it.id}">${lab}</option>`;
  }).join('');
  if(desired && Array.from(sel.options).some(o=>o.value===desired)) sel.value = desired;
}

function refreshChartMetricLabels(){
  // Defaults apply only when nothing is stored/selected yet.
  fillMetricSelect(pdX, PLAY_DRIVING_METRICS, 'Play Driving|xGF%');
  fillMetricSelect(pdY, PLAY_DRIVING_METRICS, 'Play Driving|GF%');
  fillMetricSelect(scX, SHOOTING_CONTEXT_METRICS, 'Context|Sh%');
  fillMetricSelect(scY, SHOOTING_CONTEXT_METRICS, 'Context|Sv%');

  // Apply restored axis selections once options exist.
  if(__restoreChartAxes){
    try{
      const a = __restoreChartAxes;
      if(pdX && a.pdX && Array.from(pdX.options).some(o=>o.value===a.pdX)) pdX.value = a.pdX;
      if(pdY && a.pdY && Array.from(pdY.options).some(o=>o.value===a.pdY)) pdY.value = a.pdY;
      if(scX && a.scX && Array.from(scX.options).some(o=>o.value===a.scX)) scX.value = a.scX;
      if(scY && a.scY && Array.from(scY.options).some(o=>o.value===a.scY)) scY.value = a.scY;
      __restoreChartAxes = null;
    }catch(_){/*noop*/}
  }
}

function getActiveTabKey(){
  if(tabTable?.classList.contains('active')) return 'table';
  if(tabCharts?.classList.contains('active')) return 'charts';
  if(tabEdge?.classList.contains('active')) return 'edge';
  if(tabRAPM?.classList.contains('active')) return 'rapm';
  if(tabProjections?.classList.contains('active')) return 'projections';
  return 'card';
}

function getActiveProjSubtabKey(){
  if(projTabTeam?.classList.contains('active')) return 'team';
  if(projTabLeague?.classList.contains('active')) return 'league';
  return 'player';
}

function saveSkatersState(){
  try{
    if(__isBootingSkatersPage || __isRestoringSkatersState) return;
    const state = {
      playerId: String(playerSelect?.value||''),
      activeTab: getActiveTabKey(),
      edge: {
        seasonState: String(edgeSeasonState?.value||''),
      },
      card: {
        scope: String(cardScope?.value||'season'),
        seasonState: String(cardSeasonState?.value||'regular'),
        strengthState: String(cardStrengthState?.value||'5v5'),
        rates: String(cardRates?.value||'Totals'),
        xgModel: String(cardXgModel?.value||'xG_F'),
        minGp: String(cardMinGp?.value||'0'),
        minToi: String(cardMinToi?.value||'0'),
      },
      charts: {
        highlightMode: String(__chartsHighlightMode||'team'),
        pdX: String(pdX?.value||''),
        pdY: String(pdY?.value||''),
        scX: String(scX?.value||''),
        scY: String(scY?.value||''),
      },
      projectionsSubtab: getActiveProjSubtabKey(),
    };
    localStorage.setItem(SKATERS_STATE_KEY, JSON.stringify(state));
  }catch(_){/*noop*/}
}

function restoreSkatersState(){
  try{
    __isRestoringSkatersState = true;
    const raw = localStorage.getItem(SKATERS_STATE_KEY);
    if(!raw) return;
    const state = JSON.parse(raw);
    if(state && typeof state === 'object'){
      const c = state.card || {};
      if(c && typeof c === 'object'){
        try{ setCardScope(String(c.scope||'season')); }catch(_){/*noop*/}
        try{ if(cardSeasonState && c.seasonState) cardSeasonState.value = String(c.seasonState); }catch(_){/*noop*/}
        try{ if(cardStrengthState && c.strengthState) cardStrengthState.value = String(c.strengthState); }catch(_){/*noop*/}
        try{ if(cardRates && c.rates) cardRates.value = String(c.rates); }catch(_){/*noop*/}
        try{ if(cardXgModel && c.xgModel) cardXgModel.value = String(c.xgModel); }catch(_){/*noop*/}
        try{ if(cardMinGp && c.minGp != null) cardMinGp.value = String(c.minGp); }catch(_){/*noop*/}
        try{ if(cardMinToi && c.minToi != null) cardMinToi.value = String(c.minToi); }catch(_){/*noop*/}
      }

      const e = state.edge || {};
      if(e && typeof e === 'object'){
        try{ if(edgeSeasonState && e.seasonState) edgeSeasonState.value = String(e.seasonState); }catch(_){/*noop*/}
      }

      const ch = state.charts || {};
      if(ch && typeof ch === 'object'){
        __chartsHighlightMode = (String(ch.highlightMode||'team') === 'player') ? 'player' : 'team';
        __restoreChartAxes = {
          pdX: String(ch.pdX||''),
          pdY: String(ch.pdY||''),
          scX: String(ch.scX||''),
          scY: String(ch.scY||''),
        };
      }

      __restorePlayerId = String(state.playerId||'') || null;
      __restoreActiveTab = String(state.activeTab||'') || null;
      __restoreProjSubtab = String(state.projectionsSubtab||'') || null;
    }
  }catch(_){/*noop*/}
  finally{ __isRestoringSkatersState = false; }
}

function __sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

async function initSkatersPage(){
  try{
    // Restore saved state first.
    restoreSkatersState();
    try{ setActiveProjSubtab(__restoreProjSubtab || 'player'); }catch(_){/*noop*/}
    updateCardSlicerSummary();

    setDefaultHeadshot();
    updateTabsVisibility();

    // Wait for base.html to populate the Team select.
    const t0 = Date.now();
    while(Date.now() - t0 < 6000){
      if(teamSelect && teamSelect.options && teamSelect.options.length) break;
      await __sleep(60);
    }

    // Wait for base.html to finish loading seasons.
    const s0 = Date.now();
    while(Date.now() - s0 < 8000){
      const firstTxt = String(seasonSelect?.options?.[0]?.textContent || '').toLowerCase();
      if(seasonSelect && seasonSelect.options && seasonSelect.options.length && firstTxt !== 'loading...') break;
      await __sleep(80);
    }

    // Load player list + card.
    await loadPlayers();
    await loadPlayerCard();
    applyExportButtonTextColor();

    // Re-open the last active tab.
    try{
      if(__restoreActiveTab){
        const t = String(__restoreActiveTab||'').toLowerCase();
        __restoreActiveTab = null;
        if(t) setActiveTab(t);
      }
    }catch(_){/*noop*/}
  }finally{
    __isBootingSkatersPage = false;
    saveSkatersState();
  }
}

function chartsSetHighlightMode(mode){
  const m = (mode === 'player') ? 'player' : 'team';
  __chartsHighlightMode = m;
  if(chartsHlPlayer) chartsHlPlayer.classList.toggle('active', m==='player');
  if(chartsHlTeam) chartsHlTeam.classList.toggle('active', m==='team');
  if(chartsHlPlayer) chartsHlPlayer.setAttribute('aria-pressed', m==='player' ? 'true' : 'false');
  if(chartsHlTeam) chartsHlTeam.setAttribute('aria-pressed', m==='team' ? 'true' : 'false');
  try{ __pdChart && __pdChart.update('none'); }catch(_){/*noop*/}
  try{ __scChart && __scChart.update('none'); }catch(_){/*noop*/}
  saveSkatersState();
}

try{
  chartsHlPlayer?.addEventListener('click', ()=> chartsSetHighlightMode('player'));
  chartsHlTeam?.addEventListener('click', ()=> chartsSetHighlightMode('team'));
}catch(_){/*noop*/}

async function fetchScatter(xMetricId, yMetricId){
  const season = String(seasonSelect?.value||'').trim();
  const seasonState = String(cardSeasonState?.value||'regular');
  const strengthState = String(cardStrengthState?.value||'5v5');
  const xgModel = String(cardXgModel?.value||'xG_F');
  const ratesVal = String(cardRates?.value||'Totals');
  const scopeVal = String(cardScope?.value||'season');
  const minGP = String(cardMinGp?.value||'0');
  const minTOI = String(cardMinToi?.value||'0');

  if(!season){
    return { points: [], labels: {} };
  }

  const key = JSON.stringify({ season, seasonState, strengthState, xgModel, ratesVal, scopeVal, minGP, minTOI, xMetricId, yMetricId });
  if(__scatterCache.has(key)) return __scatterCache.get(key);

  const url = `/api/skaters/scatter?season=${encodeURIComponent(season)}&seasonState=${encodeURIComponent(seasonState)}&strengthState=${encodeURIComponent(strengthState)}&xgModel=${encodeURIComponent(xgModel)}&rates=${encodeURIComponent(ratesVal)}&scope=${encodeURIComponent(scopeVal)}&minGP=${encodeURIComponent(minGP)}&minTOI=${encodeURIComponent(minTOI)}&xMetricId=${encodeURIComponent(xMetricId)}&yMetricId=${encodeURIComponent(yMetricId)}`;
  const r = await fetch(url, { cache:'no-store' });
  const data = await r.json();
  __scatterCache.set(key, data);
  return data;
}

function makeScatterChart(canvasEl, title){
  if(!canvasEl || typeof Chart === 'undefined') return null;

  const avgLinesPlugin = {
    id: 'avgLines',
    beforeDatasetsDraw(chart){
      try{
        const ds = chart?.data?.datasets?.[0];
        const pts = Array.isArray(ds?.data) ? ds.data : [];
        let sx = 0, sy = 0, n = 0;
        for(const p of pts){
          const x = Number(p?.x);
          const y = Number(p?.y);
          if(!Number.isFinite(x) || !Number.isFinite(y)) continue;
          sx += x; sy += y; n++;
        }
        if(n <= 0) return;
        const mx = sx / n;
        const my = sy / n;
        const xScale = chart.scales?.x;
        const yScale = chart.scales?.y;
        if(!xScale || !yScale) return;

        const xPix = xScale.getPixelForValue(mx);
        const yPix = yScale.getPixelForValue(my);
        const ca = chart.chartArea;
        if(!ca) return;

        const ctx = chart.ctx;
        ctx.save();
        ctx.beginPath();
        ctx.rect(ca.left, ca.top, ca.right - ca.left, ca.bottom - ca.top);
        ctx.clip();

        ctx.strokeStyle = 'rgba(255,255,255,0.18)';
        ctx.strokeStyle = 'rgba(255,255,255,0.12)';
        ctx.lineWidth = 2;

        // vertical avg line
        ctx.beginPath();
        ctx.moveTo(xPix, ca.top);
        ctx.lineTo(xPix, ca.bottom);
        ctx.stroke();

        // horizontal avg line
        ctx.beginPath();
        ctx.moveTo(ca.left, yPix);
        ctx.lineTo(ca.right, yPix);
        ctx.stroke();

        ctx.restore();
      }catch(_){/*noop*/}
    }
  };

  const highlightBadgePlugin = {
    id: 'highlightBadge',
    afterDatasetsDraw(chart){
      try{
        const ctx = chart.ctx;
        const meta = chart.getDatasetMeta(0);
        const mode = __chartsHighlightMode;
        const wantTeam = String(teamSelect?.value||'').toUpperCase();
        const wantPid = String(playerSelect?.value||'');
        const season = String(seasonSelect?.value||'').trim();
        const selectedTeam = String(teamSelect?.value||'').trim();
        meta.data.forEach((ptEl, i)=>{
          const raw = chart.data.datasets[0].data[i];
          if(!raw) return;
          const isHit = (mode === 'player')
            ? (wantPid && String(raw.playerId) === wantPid)
            : (wantTeam && String(raw.team||'').toUpperCase() === wantTeam);
          if(!isHit) return;
          const p = ptEl.getProps(['x','y'], true);

          const outerR = 14;
          // Keep the overall badge size the same (outerR), but let the image fill more of it.
          const innerR = 12.6;

          ctx.save();
          // Backplate + ring
          ctx.beginPath();
          ctx.fillStyle = 'rgba(10,14,22,0.92)';
          ctx.arc(p.x, p.y, outerR, 0, Math.PI*2);
          ctx.fill();
          ctx.lineWidth = 3.5;
          ctx.strokeStyle = 'rgba(255,255,255,0.92)';
          ctx.stroke();

          // Clip + image inside circle
          ctx.beginPath();
          ctx.arc(p.x, p.y, innerR, 0, Math.PI*2);
          ctx.clip();

          let img = null;
          if(mode === 'player'){
            // Player highlight uses the selected player's mug.
            img = getPlayerMugImage(season, selectedTeam, raw.playerId);
          }else{
            // Team highlight uses team logo.
            img = getTeamLogoImage(raw.team);
          }

          if(img && img.complete){
            const d = innerR * 2;
            const pad = (mode === 'team') ? 0.35 : 0.0;
            const zoom = (mode === 'player') ? 1.18 : 1.08;

            // Note: NHL team logos are often SVG, which may report naturalWidth=0.
            // In that case, fall back to a simple drawImage without source-cropping.
            const iw = Number(img.naturalWidth || img.width || 0);
            const ih = Number(img.naturalHeight || img.height || 0);
            const side = Math.min(iw, ih);

            try{
              if(side > 0 && Number.isFinite(zoom) && zoom > 0){
                const crop = side / zoom;
                if(crop > 0){
                  const sx = (iw - crop) / 2;
                  const sy = (ih - crop) / 2;
                  ctx.drawImage(
                    img,
                    sx, sy, crop, crop,
                    p.x - innerR + pad,
                    p.y - innerR + pad,
                    d - 2*pad,
                    d - 2*pad
                  );
                }else{
                  ctx.drawImage(img, p.x - innerR + pad, p.y - innerR + pad, d - 2*pad, d - 2*pad);
                }
              }else{
                ctx.drawImage(img, p.x - innerR + pad, p.y - innerR + pad, d - 2*pad, d - 2*pad);
              }
            }catch(_){
              try{ ctx.drawImage(img, p.x - innerR + pad, p.y - innerR + pad, d - 2*pad, d - 2*pad); }catch(__){/*noop*/}
            }
          }
          ctx.restore();
        });
      }catch(_){/*noop*/}
    }
  };

  const chart = new Chart(canvasEl.getContext('2d'), {
    type: 'scatter',
    data: {
      datasets: [{
        label: title,
        data: [],
        pointBackgroundColor: (ctx)=>{
          const raw = ctx.raw || {};
          const mode = __chartsHighlightMode;
          const wantTeam = String(teamSelect?.value||'').toUpperCase();
          const wantPid = String(playerSelect?.value||'');
          const isHit = (mode === 'player')
            ? (wantPid && String(raw.playerId) === wantPid)
            : (wantTeam && String(raw.team||'').toUpperCase() === wantTeam);
          return isHit ? 'rgba(0,0,0,0)' : 'rgba(255,255,255,0.16)';
        },
        pointBorderColor: (ctx)=>{
          const raw = ctx.raw || {};
          const mode = __chartsHighlightMode;
          const wantTeam = String(teamSelect?.value||'').toUpperCase();
          const wantPid = String(playerSelect?.value||'');
          const isHit = (mode === 'player')
            ? (wantPid && String(raw.playerId) === wantPid)
            : (wantTeam && String(raw.team||'').toUpperCase() === wantTeam);
          return isHit ? 'rgba(0,0,0,0)' : 'rgba(255,255,255,0.10)';
        },
        pointBorderWidth: (ctx)=>{
          const raw = ctx.raw || {};
          const mode = __chartsHighlightMode;
          const wantTeam = String(teamSelect?.value||'').toUpperCase();
          const wantPid = String(playerSelect?.value||'');
          const isHit = (mode === 'player')
            ? (wantPid && String(raw.playerId) === wantPid)
            : (wantTeam && String(raw.team||'').toUpperCase() === wantTeam);
          return isHit ? 0 : 1;
        },
        pointRadius: (ctx)=>{
          const raw = ctx.raw || {};
          const mode = __chartsHighlightMode;
          const wantTeam = String(teamSelect?.value||'').toUpperCase();
          const wantPid = String(playerSelect?.value||'');
          const isHit = (mode === 'player')
            ? (wantPid && String(raw.playerId) === wantPid)
            : (wantTeam && String(raw.team||'').toUpperCase() === wantTeam);
          // The actual highlight badge is drawn by the plugin.
          return isHit ? 10 : 4;
        },
        pointHoverRadius: 10,
        pointStyle: 'circle',
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display:false },
        tooltip: {
          callbacks: {
            label: (t)=>{
              const r = t.raw || {};
              const nm = r.name || '';
              const tm = r.team ? ` (${r.team})` : '';
              return `${nm}${tm}: ${t.parsed.x.toFixed(3)}, ${t.parsed.y.toFixed(3)}`;
            }
          }
        }
      },
      scales: {
        x: { title: { display:true, text:'X', color:'rgba(255,255,255,0.95)' }, grid: { color:'rgba(255,255,255,0.06)' }, ticks:{ color:'rgba(255,255,255,0.75)' } },
        y: { title: { display:true, text:'Y', color:'rgba(255,255,255,0.95)' }, grid: { color:'rgba(255,255,255,0.06)' }, ticks:{ color:'rgba(255,255,255,0.75)' } },
      }
    },
    plugins: [avgLinesPlugin, highlightBadgePlugin]
  });

  return chart;
}

async function renderCharts(){
  if(!tabPanelCharts) return;
  const season = String(seasonSelect?.value||'').trim();
  if(!season){
    if(chartsEmpty) chartsEmpty.hidden = false;
    if(chartsGrid) chartsGrid.style.display = 'none';
    return;
  }

  function setChartsLoading(on, text){
    if(chartsEmpty){
      chartsEmpty.hidden = !on;
      if(on) chartsEmpty.textContent = text || 'Loading charts...';
    }
    if(chartsGrid){
      chartsGrid.style.display = '';
      chartsGrid.style.opacity = on ? '0.35' : '';
      chartsGrid.style.pointerEvents = on ? 'none' : '';
    }
  }

  setChartsLoading(true, 'Loading charts...');

  refreshChartMetricLabels();
  chartsSetHighlightMode(__chartsHighlightMode);

  if(!__pdChart && pdChartEl) __pdChart = makeScatterChart(pdChartEl, 'Play Driving');
  if(!__scChart && scChartEl) __scChart = makeScatterChart(scChartEl, 'Shooting and Context');

  const keyNow = JSON.stringify({
    tab:'charts',
    season,
    seasonState:String(cardSeasonState?.value||''),
    strengthState:String(cardStrengthState?.value||''),
    xgModel:String(cardXgModel?.value||''),
    rates:String(cardRates?.value||''),
    scope:String(cardScope?.value||''),
    minGP:String(cardMinGp?.value||''),
    minTOI:String(cardMinToi?.value||''),
    pdX:String(pdX?.value||''),
    pdY:String(pdY?.value||''),
    scX:String(scX?.value||''),
    scY:String(scY?.value||''),
  });
  if(keyNow === __chartsLastKey){
    setChartsLoading(false);
    return;
  }
  __chartsLastKey = keyNow;

  try{
    const [pd, sc] = await Promise.all([
      fetchScatter(String(pdX?.value||''), String(pdY?.value||'')),
      fetchScatter(String(scX?.value||''), String(scY?.value||'')),
    ]);

    if(__pdChart){
      __pdChart.options.scales.x.title.text = metricLabel(String(pdX?.value||''));
      __pdChart.options.scales.y.title.text = metricLabel(String(pdY?.value||''));
      __pdChart.options.scales.x.reverse = isAgainstMetric(String(pdX?.value||''));
      __pdChart.options.scales.y.reverse = isAgainstMetric(String(pdY?.value||''));
      __pdChart.data.datasets[0].data = Array.isArray(pd?.points) ? pd.points : [];
      __pdChart.update('none');
    }
    if(__scChart){
      __scChart.options.scales.x.title.text = metricLabel(String(scX?.value||''));
      __scChart.options.scales.y.title.text = metricLabel(String(scY?.value||''));
      __scChart.options.scales.x.reverse = isAgainstMetric(String(scX?.value||''));
      __scChart.options.scales.y.reverse = isAgainstMetric(String(scY?.value||''));
      __scChart.data.datasets[0].data = Array.isArray(sc?.points) ? sc.points : [];
      __scChart.update('none');
    }

    setChartsLoading(false);
  }catch(e){
    if(chartsEmpty){
      chartsEmpty.hidden = false;
      chartsEmpty.textContent = 'Error loading charts.';
    }
    if(chartsGrid){
      chartsGrid.style.display = 'none';
      chartsGrid.style.opacity = '';
      chartsGrid.style.pointerEvents = '';
    }
  }
}

function setCardScope(scope){
  const s = (String(scope||'').toLowerCase() === 'career') ? 'career' : 'season';
  if(cardScope) cardScope.value = s;
  try{
    const btns = cardScopeButtons ? Array.from(cardScopeButtons.querySelectorAll('button[data-scope]')) : [];
    btns.forEach(b=>{
      const v = String(b.getAttribute('data-scope')||'').toLowerCase();
      b.classList.toggle('active', v === s);
      b.setAttribute('aria-pressed', v === s ? 'true' : 'false');
    });
  }catch(_){ /* ignore */ }

  updateCardSlicerSummary();
  saveSkatersState();
}

// Wire Scope segmented buttons.
try{
  const btns = cardScopeButtons ? Array.from(cardScopeButtons.querySelectorAll('button[data-scope]')) : [];
  btns.forEach(b=>{
    b.addEventListener('click', ()=>{
      setCardScope(b.getAttribute('data-scope'));
      loadCardPanel();
      try{
        __chartsLastKey='';
        if(tabCharts?.classList.contains('active')) renderCharts();
      }catch(_){/*noop*/}
    });
  });
  setCardScope(cardScope?.value || 'season');
}catch(_){ /* ignore */ }

function seasonToStartYear(season){
  const s = String(season||'').trim();
  if(s.length >= 4) return parseInt(s.slice(0,4),10);
  return null;
}

function calcAgeOnOct1(birthDateStr, season){
  if(!birthDateStr) return null;
  const startYear = seasonToStartYear(season);
  if(!startYear) return null;
  const birth = new Date(birthDateStr + 'T00:00:00Z');
  if(isNaN(birth)) return null;
  const ref = new Date(Date.UTC(startYear, 9, 1));
  let age = ref.getUTCFullYear() - birth.getUTCFullYear();
  const m = ref.getUTCMonth() - birth.getUTCMonth();
  if(m < 0 || (m === 0 && ref.getUTCDate() < birth.getUTCDate())) age--;
  return age;
}

function inchesToFeetIn(inches){
  const n = Number(inches);
  if(!Number.isFinite(n)) return null;
  const ft = Math.floor(n/12);
  const inch = n % 12;
  return `${ft}'${inch}"`;
}

function setMsg(text, isError=false){
  if(!skaterMsg) return;
  skaterMsg.textContent = text || '';
  skaterMsg.className = 'skater-empty' + (isError ? ' err' : '');
}

function setDefaultHeadshot(){
  if(!skaterImg) return;
  try{ skaterImg.onerror = null; }catch(_){/*noop*/}
  try{ skaterImg.dataset.fallbackDone = '0'; }catch(_){/*noop*/}
  skaterImg.src = DEFAULT_SKATER_IMG;
}

function setHeadshot(team, season, playerId){
  const s = String(season||'').trim();
  const t = String(team||'').trim();
  const pid = String(playerId||'').trim();
  if(!pid){
    setDefaultHeadshot();
    return;
  }
  const primary = `https://assets.nhle.com/mugs/nhl/${s}/${t}/${pid}.png`;
  const fallback = `https://assets.nhle.com/mugs/nhl/latest/${pid}.png`;
  skaterImg.onerror = () => {
    if(skaterImg.dataset.fallbackDone === '1') return;
    skaterImg.dataset.fallbackDone = '1';
    skaterImg.src = fallback;
  };
  skaterImg.dataset.fallbackDone = '0';
  skaterImg.src = primary;
}

function renderPlayerLanding(landing){
  const first = landing?.firstName?.default || '';
  const last = landing?.lastName?.default || '';
  const full = (first + ' ' + last).trim() || 'Unknown player';
  skaterName.textContent = full;

  const season = seasonSelect?.value;
  const age = calcAgeOnOct1(landing?.birthDate, season);

  const height = inchesToFeetIn(landing?.heightInInches);
  const heightCm = landing?.heightInCentimeters;
  const weightLb = landing?.weightInPounds;
  const weightKg = landing?.weightInKilograms;

  const draft = landing?.draftDetails || {};
  const draftYear = draft?.year;
  const overallPick = draft?.overallPick;

  const parts = [];
  if(height || heightCm) parts.push({k:'Height', v: [height, heightCm?`${heightCm} cm`:null].filter(Boolean).join(' • ')});
  if(weightLb || weightKg) parts.push({k:'Weight', v: [weightLb?`${weightLb} lb`:null, weightKg?`${weightKg} kg`:null].filter(Boolean).join(' • ')});
  if(age != null) parts.push({k:'Age', v: `${age}`});
  if(draftYear) parts.push({k:'Draft', v: overallPick?`${draftYear} • #${overallPick}`:`${draftYear}`});

  skaterInfo.innerHTML = parts.map(p=>`<div class="kv"><span class="k">${p.k}</span><span class="v">${p.v}</span></div>`).join('');
}

function setActiveTab(which){
  const w = String(which || '').toLowerCase();
  const isC = (w === 'card');
  const isT = (w === 'table');
  const isH = (w === 'charts');
  const isE = (w === 'edge');
  const isR = (w === 'rapm');
  const isP = (w === 'projections');
  // default
  const finalC = (isC || (!isT && !isH && !isE && !isR && !isP));
  const finalT = isT;
  const finalH = isH;
  const finalE = isE;
  const finalR = isR;
  const finalP = isP;

  tabCard?.classList.toggle('active', finalC);
  tabTable?.classList.toggle('active', finalT);
  tabCharts?.classList.toggle('active', finalH);
  tabEdge?.classList.toggle('active', finalE);
  tabRAPM?.classList.toggle('active', finalR);
  tabProjections?.classList.toggle('active', finalP);
  if(tabCard) tabCard.setAttribute('aria-selected', finalC ? 'true' : 'false');
  if(tabTable) tabTable.setAttribute('aria-selected', finalT ? 'true' : 'false');
  if(tabCharts) tabCharts.setAttribute('aria-selected', finalH ? 'true' : 'false');
  if(tabEdge) tabEdge.setAttribute('aria-selected', finalE ? 'true' : 'false');
  if(tabRAPM) tabRAPM.setAttribute('aria-selected', finalR ? 'true' : 'false');
  if(tabProjections) tabProjections.setAttribute('aria-selected', finalP ? 'true' : 'false');
  if(tabPanelCard) tabPanelCard.style.display = finalC ? '' : 'none';
  if(tabPanelTable) tabPanelTable.style.display = finalT ? '' : 'none';
  if(tabPanelCharts) tabPanelCharts.style.display = finalH ? '' : 'none';
  if(tabPanelEdge) tabPanelEdge.style.display = finalE ? '' : 'none';
  if(tabPanelRAPM) tabPanelRAPM.style.display = finalR ? '' : 'none';
  if(tabPanelProjections) tabPanelProjections.style.display = finalP ? '' : 'none';

  // Card slicers are shared by Card + Table + Charts.
  setCardSlicersVisible(finalC || finalT || finalH, { showConfig: finalC });
  setEdgeSlicersVisible(finalE);

  // Keep Edge season state in sync with Card selection when possible.
  if(finalE && edgeSeasonState){
    const cs = String(cardSeasonState?.value || 'regular');
    const v = (cs === 'playoffs') ? 'playoffs' : 'regular';
    try{ edgeSeasonState.value = v; }catch(_){/*noop*/}
  }

  if(finalC) loadCardPanel();
  if(finalT) loadTablePanel();
  if(finalH) {
    // Render charts when the tab becomes active.
    try{ __chartsLastKey=''; renderCharts(); }catch(_){ /* noop */ }
  }
  if(finalE) loadEdgePanel();
  if(finalR) loadRAPMPanel();
  if(finalP && projectionsEnabled()) loadProjectionsPanel();

  saveSkatersState();
}

function setEdgeSlicersVisible(on){
  const show = !!on;
  if(edgeSeasonStateWrap) edgeSeasonStateWrap.style.display = show ? '' : 'none';
}

function edgeEnabled(){
  return true;
}

function _edgeStrengthLabel(v){
  const s = String(v||'').toLowerCase();
  if(s === 'all') return 'All';
  if(s === 'es') return 'EV';
  if(s === 'pp') return 'PP';
  if(s === 'pk') return 'SH';
  return 'All';
}

function _edgeStrengthToCode(v){
  const s = String(v||'').toLowerCase();
  if(s === 'ev' || s === 'es') return 'es';
  if(s === 'pp') return 'pp';
  if(s === 'sh' || s === 'pk') return 'pk';
  return 'all';
}

function _edgeVal(obj){
  const v = Number(obj?.value);
  return Number.isFinite(v) ? v : null;
}

function _edgePct(obj){
  const p = Number(obj?.pct);
  return Number.isFinite(p) ? p : null;
}

function _edgeFmtValue(metricKey, value){
  const v = Number(value);
  if(!Number.isFinite(v)) return '—';
  const m = String(metricKey||'');
  if(m === 'topShotSpeed' || m === 'avgShotSpeed' || m === 'maxSkatingSpeed') return v.toFixed(1);
  if(m === 'distanceTotal' || m === 'distancePer60') return v.toFixed(1);
  if(m.endsWith('Pctg')){
    // Some Edge payloads encode zone time as 0..1 rather than 0..100.
    const vv = (0.0 <= v && v <= 1.0) ? (100.0 * v) : v;
    return vv.toFixed(1) + '%';
  }
  // counts
  return String(Math.round(v));
}

function _ordinal(n){
  const x = Math.round(Number(n));
  if(!Number.isFinite(x)) return '';
  const mod100 = x % 100;
  if(mod100 >= 11 && mod100 <= 13) return `${x}th`;
  const mod10 = x % 10;
  if(mod10 === 1) return `${x}st`;
  if(mod10 === 2) return `${x}nd`;
  if(mod10 === 3) return `${x}rd`;
  return `${x}th`;
}

function renderEdgeZoneKpi(metricKey, obj, zoneLabel){
  const p = _edgePct(obj);
  const pctOk = (p != null);
  const pctLabel = !pctOk ? '—' : _ordinal(p);
  const accent = pctOk ? pctToColor(p) : 'rgba(255,255,255,0.55)';
  const valText = _edgeFmtValue(metricKey, obj?.value);
  const avgText = _edgeFmtValue(metricKey, obj?.avg);
  const showAvg = (obj?.avg != null) && avgText !== '—';
  return `
    <div class="edge-zone-pill" style="border-color:${accent}; color:${accent};">${pctLabel}</div>
    <div class="edge-zone-value">${valText}</div>
    ${showAvg ? `<div class="edge-zone-avg">NHL Avg ${avgText}</div>` : ''}
    <div class="edge-zone-label">${zoneLabel}</div>
  `;
}

function renderEdgeMetricBar(label, metricKey, obj){
  const pct = _edgePct(obj);
  const pctOk = Number.isFinite(Number(pct));
  const width = pctOk ? clamp(Number(pct), 0, 100).toFixed(1) : '0.0';
  const color = pctOk ? pctToColor(Number(pct)) : 'rgba(255,255,255,0.15)';
  const valText = _edgeFmtValue(metricKey, obj?.value);
  return `
    <div class="metric">
      <div class="metric-head">
        <div class="metric-name">${label}</div>
        <div class="metric-val">${valText}</div>
      </div>
      <div class="metric-bar"><div class="metric-fill" style="width:${width}%; background:${color};"></div></div>
    </div>
  `;
}

function renderEdgeUI(data){
  if(!edgePanelInner) return;
  __edgeData = data || null;

  if(!data || data?.available === false){
    const season = String(seasonSelect?.value || '').trim();
    edgePanelInner.innerHTML = `
      <div class="skater-empty" style="padding:10px 0;">
        NHL Edge data is available starting in 2021/22. (Selected season: ${season || '—'})
      </div>
    `;
    return;
  }

  edgePanelInner.innerHTML = `
    <div class="edge-grid">
      <div class="edge-card card-col">
        <div class="card-slot">
          <h3>Shot Speed</h3>
          <div id="edgeShotBars"></div>
        </div>
        <div class="card-slot">
          <h3>Skating Speed</h3>
          <div id="edgeSkateBars"></div>
        </div>
      </div>

      <div class="edge-card card-col">
        <div class="edge-controls">
          <div class="edge-control">
            <label for="edgeStrength">Strength</label>
            <select id="edgeStrength" class="edge-select">
              <option value="all">All</option>
              <option value="es">EV</option>
              <option value="pp">PP</option>
              <option value="pk">SH</option>
            </select>
          </div>
        </div>

        <div class="card-slot">
          <h3>Skating Distance</h3>
          <div id="edgeDistanceBars"></div>
        </div>
        <div class="card-slot">
          <h3>Zone Time</h3>
          <div class="edge-zone-rink">
            <img src="/static/hockey-rink.png" alt="Hockey rink" loading="lazy" />
            <div class="edge-zone-kpi-row">
              <div id="edgeZoneDef" class="edge-zone-kpi"></div>
              <div id="edgeZoneNeu" class="edge-zone-kpi"></div>
              <div id="edgeZoneOff" class="edge-zone-kpi"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  `;

  const shot = data?.shotSpeed || {};
  const skate = data?.skatingSpeed || {};
  const shotWrap = document.getElementById('edgeShotBars');
  const skateWrap = document.getElementById('edgeSkateBars');
  if(shotWrap){
    shotWrap.innerHTML = [
      renderEdgeMetricBar('Top Shot Speed', 'topShotSpeed', shot?.topShotSpeed),
      renderEdgeMetricBar('Average Shot Speed', 'avgShotSpeed', shot?.avgShotSpeed),
      renderEdgeMetricBar('Shots over 100 MPH', 'shotAttemptsOver100', shot?.shotAttemptsOver100),
      renderEdgeMetricBar('Shots 90 to 100 MPH', 'shotAttempts90to100', shot?.shotAttempts90to100),
      renderEdgeMetricBar('Shots 80 to 90 MPH', 'shotAttempts80to90', shot?.shotAttempts80to90),
      renderEdgeMetricBar('Shots 70 to 80 MPH', 'shotAttempts70to80', shot?.shotAttempts70to80),
    ].join('');
  }
  if(skateWrap){
    skateWrap.innerHTML = [
      renderEdgeMetricBar('Top Skating Speed', 'maxSkatingSpeed', skate?.maxSkatingSpeed),
      renderEdgeMetricBar('Speed Bursts 22+ MPH', 'burstsOver22', skate?.burstsOver22),
      renderEdgeMetricBar('Speed Bursts 20 to 22 MPH', 'bursts20to22', skate?.bursts20to22),
      renderEdgeMetricBar('Speed Bursts 18 to 20 MPH', 'bursts18to20', skate?.bursts18to20),
    ].join('');
  }

  const selStrength = document.getElementById('edgeStrength');
  if(selStrength){
    selStrength.value = String(__edgeStrength || 'all');
    selStrength.onchange = () => {
      __edgeStrength = String(selStrength.value || 'all');
      renderEdgeStrengthPanels();
    };
  }

  renderEdgeStrengthPanels();
}

function renderEdgeStrengthPanels(){
  const data = __edgeData;
  if(!data || data?.available === false) return;
  const sc = _edgeStrengthToCode(__edgeStrength);

  const dist = data?.skatingDistance?.[sc] || data?.skatingDistance?.all || {};
  const zone = data?.zoneTime?.[sc] || data?.zoneTime?.all || {};

  const distWrap = document.getElementById('edgeDistanceBars');
  const zoneDef = document.getElementById('edgeZoneDef');
  const zoneNeu = document.getElementById('edgeZoneNeu');
  const zoneOff = document.getElementById('edgeZoneOff');
  if(distWrap){
    distWrap.innerHTML = [
      renderEdgeMetricBar('Total Skating Distance', 'distanceTotal', dist?.distanceTotal),
      renderEdgeMetricBar('Skating Distance Per 60', 'distancePer60', dist?.distancePer60),
    ].join('');
  }
  if(zoneDef) zoneDef.innerHTML = renderEdgeZoneKpi('defensiveZonePctg', zone?.defensiveZonePctg, 'Defensive Zone');
  if(zoneNeu) zoneNeu.innerHTML = renderEdgeZoneKpi('neutralZonePctg', zone?.neutralZonePctg, 'Neutral Zone');
  if(zoneOff) zoneOff.innerHTML = renderEdgeZoneKpi('offensiveZonePctg', zone?.offensiveZonePctg, 'Offensive Zone');
}

async function loadEdgePanel(){
  if(!edgePanelInner) return;
  if(!edgeEnabled()){
  }
  const playerId = String(playerSelect?.value || '').trim();
  const season = String(seasonSelect?.value || '').trim() || '20252026';
  const seasonState = String(edgeSeasonState?.value || 'regular');

  if(!playerId){
    edgePanelInner.textContent = 'Select a player to view Edge metrics.';
    return;
  }

  edgePanelInner.textContent = 'Loading Edge metrics...';
  try{
    const key = `${playerId}|${season||''}|${seasonState||''}`;
    if(__edgeKey !== key){
      __edgeKey = key;
      __edgeCache = null;
      __edgeData = null;
    }

    if(!__edgeCache){
      const url = `/api/skaters/edge?season=${encodeURIComponent(season||'')}&playerId=${encodeURIComponent(playerId)}&seasonState=${encodeURIComponent(seasonState||'regular')}`;
      const r = await fetch(url, { cache:'no-store' });
      __edgeCache = await r.json();
    }
    renderEdgeUI(__edgeCache);
  }catch(_){
    edgePanelInner.textContent = 'Error loading Edge metrics.';
  }
}

function setCardSlicersVisible(on, opts){
  const show = !!on;
  const showConfig = !!(opts && opts.showConfig);
  // Configure button lives in the Card panel header; only show it on Card.
  if(btnConfigureCard) btnConfigureCard.style.display = showConfig ? '' : 'none';
  if(cardSlicerSummary) cardSlicerSummary.style.display = showConfig ? '' : 'none';
  if(cardScopeWrap) cardScopeWrap.style.display = show ? '' : 'none';
  if(cardSeasonStateWrap) cardSeasonStateWrap.style.display = show ? '' : 'none';
  if(cardMinGpWrap) cardMinGpWrap.style.display = show ? '' : 'none';
  if(cardMinToiWrap) cardMinToiWrap.style.display = show ? '' : 'none';
  if(cardStrengthStateWrap) cardStrengthStateWrap.style.display = show ? '' : 'none';
  if(cardRatesWrap) cardRatesWrap.style.display = show ? '' : 'none';
  if(cardXgModelWrap) cardXgModelWrap.style.display = show ? '' : 'none';
}

function updateCardSlicerSummary(){
  if(!cardSlicerSummary && !chartsSlicerSummary) return;
  const scope = String(cardScope?.value || 'season');
  const rawSeason = String(seasonSelect?.value || '').trim();
  let season = rawSeason;
  if(/^\d{8}$/.test(rawSeason)){
    season = `${rawSeason.slice(0,4)}/${rawSeason.slice(4,8)}`;
  }
  const seasonState = String(cardSeasonState?.selectedOptions?.[0]?.textContent || cardSeasonState?.value || '').trim();
  const strengthState = String(cardStrengthState?.selectedOptions?.[0]?.textContent || cardStrengthState?.value || '').trim();
  const ratesText = String(cardRates?.selectedOptions?.[0]?.textContent || cardRates?.value || '').trim();
  const minGp = Number.parseInt(String(cardMinGp?.value || '0'), 10);
  const minToi = Number(String(cardMinToi?.value || '0'));
  const minParts = [];
  if(Number.isFinite(minGp) && minGp > 0) minParts.push(`Min GP ${minGp}`);
  if(Number.isFinite(minToi) && minToi > 0) minParts.push(`Min TOI ${minToi}`);

  const first = (scope === 'career') ? 'Career' : season;
  const parts = [first, seasonState, strengthState, ratesText].concat(minParts).filter(Boolean);
  const text = parts.join(' - ');
  if(cardSlicerSummary) cardSlicerSummary.textContent = text;
  if(chartsSlicerSummary) chartsSlicerSummary.textContent = text;
}

function projectionsEnabled(){
  return String(seasonSelect?.value || '').trim() === '20252026';
}

function cardEnabled(){
  // Card supports all seasons (20252026 from Sheets6; others from nhl_seasonstats.csv)
  return true;
}

function updateTabsVisibility(){
  const enabled = projectionsEnabled();
  if(tabProjections) tabProjections.style.display = enabled ? '' : 'none';
  const projActive = tabProjections?.classList.contains('active');
  if(!enabled && projActive) setActiveTab('card');
}

// base.html populates seasonSelect asynchronously and sets seasonSelect.value
// without dispatching a change event. In slower environments (prod), our initial
// updateTabsVisibility() can run before the value is set, hiding Projections.
// This watcher ensures the tab visibility stays in sync once the season loads.
let __seasonWatchTimer = null;
let __seasonWatchLast = null;
function __isSeasonId(v){ return /^\d{8}$/.test(String(v||'')); }
function installSeasonWatcher(){
  if(__seasonWatchTimer) return;
  __seasonWatchLast = String(seasonSelect?.value || '').trim();
  const startedAt = Date.now();
  __seasonWatchTimer = setInterval(()=>{
    const v = String(seasonSelect?.value || '').trim();
    if(v !== __seasonWatchLast && __isSeasonId(v)){
      __seasonWatchLast = v;
      updateTabsVisibility();
    }
    if(Date.now() - startedAt > 12000){
      clearInterval(__seasonWatchTimer);
      __seasonWatchTimer = null;
    }
  }, 200);
}
installSeasonWatcher();

// Edge slicer should only show when Edge tab is active.
setEdgeSlicersVisible(false);

// Default tab is Card; keep sidebar slicers in sync on initial load.
setCardSlicersVisible(true);

function safeJsonParse(s){
  try{ return JSON.parse(String(s||'')); }catch(_){ return null; }
}

function escapeHtml(value){
  const s = String(value ?? '');
  return s.replace(/[&<>"']/g, (ch)=>({
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
  }[ch] || ch));
}

async function ensureCardDefs(){
  if(__cardDefs) return __cardDefs;
  try{
    const r = await fetch('/api/skaters/card/defs', { cache:'no-store' });
    const js = await r.json();
    __cardDefs = js && typeof js === 'object' ? js : { categories:[], metrics:[] };
  }catch(_){
    __cardDefs = { categories:[], metrics:[] };
  }
  return __cardDefs;
}

function buildDefaultCardConfig(defs){
  const metrics = Array.isArray(defs?.metrics) ? defs.metrics : [];
  const categories = Array.isArray(defs?.categories) ? defs.categories : [];
  const byCat = {};
  metrics.forEach(m=>{
    const c = String(m?.category||'').trim();
    if(!c) return;
    (byCat[c] = byCat[c] || []).push(m);
  });

  const categorySelected = {};
  const categoryPlace = {};
  categories.forEach(c=>{
    const cat = String(c||'').trim();
    const ms = byCat[cat] || [];
    const defaults = ms.filter(x=>String(x?.default||'').trim() === '1' || x?.default === true || String(x?.default||'').toLowerCase()==='true');
    categorySelected[cat] = defaults.map(x=>String(x?.id||'')).filter(Boolean);
    const p = (defaults.find(x=>String(x?.place||'').trim() && String(x?.place||'').trim() !== '0') || ms.find(x=>String(x?.place||'').trim() && String(x?.place||'').trim() !== '0'));
    if(p) categoryPlace[cat] = String(p.place).trim();
  });

  const slots = {};
  CARD_SLOTS.forEach(s=>{ slots[s] = null; });
  Object.entries(categoryPlace).forEach(([cat, place])=>{
    if(CARD_SLOTS.includes(place)) slots[place] = cat;
  });
  return { version: 1, slots, categorySelected };
}

function loadCardConfig(defs){
  const raw = safeJsonParse(localStorage.getItem(CARD_CONFIG_KEY));
  if(raw && typeof raw === 'object' && raw.slots && raw.categorySelected) return raw;
  return buildDefaultCardConfig(defs);
}

function saveCardConfig(cfg){
  try{ localStorage.setItem(CARD_CONFIG_KEY, JSON.stringify(cfg)); }catch(_){ /* ignore */ }
}

function downloadTextFile(filename, text, mime='application/json'){
  try{
    const blob = new Blob([String(text||'')], { type: mime });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{
      try{ URL.revokeObjectURL(a.href); }catch(_){/*noop*/}
      try{ a.remove(); }catch(_){/*noop*/}
    }, 250);
  }catch(_){ /* ignore */ }
}

function normalizeCardConfig(defs, cfg){
  const metrics = Array.isArray(defs?.metrics) ? defs.metrics : [];
  const categories = new Set((Array.isArray(defs?.categories) ? defs.categories : []).map(String));
  const allowedMetricIds = new Set(metrics.map(m=>String(m?.id||'')).filter(Boolean));

  const out = { version: 1, slots: {}, categorySelected: {} };
  // slots
  const slotsIn = cfg?.slots && typeof cfg.slots === 'object' ? cfg.slots : {};
  CARD_SLOTS.forEach(s=>{ out.slots[s] = null; });
  CARD_SLOTS.forEach(s=>{
    const cat = slotsIn?.[s];
    const c = (cat == null || cat === '') ? null : String(cat);
    if(c && categories.has(c)) out.slots[s] = c;
  });
  // enforce uniqueness (first wins)
  const seen = new Set();
  CARD_SLOTS.forEach(s=>{
    const c = out.slots[s];
    if(!c) return;
    if(seen.has(c)) out.slots[s] = null;
    else seen.add(c);
  });

  // metric selections
  const selIn = cfg?.categorySelected && typeof cfg.categorySelected === 'object' ? cfg.categorySelected : {};
  categories.forEach(cat=>{
    const arr = Array.isArray(selIn?.[cat]) ? selIn[cat] : [];
    out.categorySelected[cat] = arr.map(String).filter(id=>allowedMetricIds.has(id));
  });

  return out;
}

async function exportCardConfig(){
  const defs = await ensureCardDefs();
  const cfg = __cardConfig || loadCardConfig(defs);
  const norm = normalizeCardConfig(defs, cfg);
  const text = JSON.stringify(norm, null, 2);
  downloadTextFile('skaters_card_config.json', text, 'application/json');
  try{
    if(navigator?.clipboard?.writeText){
      await navigator.clipboard.writeText(text);
    }
  }catch(_){ /* ignore clipboard failures */ }
}

async function importCardConfigFromText(text){
  const defs = await ensureCardDefs();
  const parsed = safeJsonParse(text);
  if(!parsed || typeof parsed !== 'object'){
    alert('Invalid JSON.');
    return;
  }
  const norm = normalizeCardConfig(defs, parsed);
  __cardConfig = norm;
  saveCardConfig(norm);
  renderCardConfigModal(defs, __cardConfig);
  loadCardPanel();
}

function openCardConfig(){
  if(cardConfigModal) cardConfigModal.hidden = false;
}
function closeCardConfig(){
  if(cardConfigModal) cardConfigModal.hidden = true;
}

function renderCardConfigModal(defs, cfg){
  if(!ccGrid) return;
  const categories = Array.isArray(defs?.categories) ? defs.categories : [];
  const metrics = Array.isArray(defs?.metrics) ? defs.metrics : [];
  const byCat = {};
  metrics.forEach(m=>{
    const c = String(m?.category||'').trim();
    if(!c) return;
    (byCat[c] = byCat[c] || []).push(m);
  });

  function categoryOptionsHtml(assignedCat){
    const opts = [''].concat(categories.map(String));
    return opts.map(c=>{
      const v = String(c||'');
      const sel = (v && v === String(assignedCat||'')) ? ' selected' : '';
      const label = v ? v : '(empty)';
      return `<option value="${v}"${sel}>${label}</option>`;
    }).join('');
  }

  function metricsHtmlForCategory(cat){
    const c = String(cat||'').trim();
    if(!c) return '<div class="cc-help" style="margin:10px 0 0;">Select a category to choose metrics.</div>';
    const ms = byCat[c] || [];
    const selected = new Set((cfg?.categorySelected?.[c] || []).map(String));
    const checks = ms.map(m=>{
      const id = String(m?.id||'');
      const name = String(m?.name || m?.metric || id);
      const checked = selected.has(id) ? ' checked' : '';
      return `<label class="cc-metric"><input type="checkbox" data-mid="${id}" data-cat="${c}"${checked}/><span>${name}</span></label>`;
    }).join('');
    return `<div class="cc-metrics" style="margin-top:10px;">${checks || '<div class="cc-help">No metrics</div>'}</div>`;
  }

  ccGrid.innerHTML = CARD_SLOTS.map(slot=>{
    const assignedCat = String(cfg?.slots?.[slot] || '');
    return `
      <div class="cc-slot" data-slot="${slot}">
        <div class="s">${slot}</div>
        <div class="cc-row" style="margin-top:8px; margin-bottom:0;">
          <div style="min-width:70px; font-weight:850;">Category</div>
          <select data-slot="${slot}" class="cc-assign" style="flex:1; min-width:0;">${categoryOptionsHtml(assignedCat)}</select>
        </div>
        ${metricsHtmlForCategory(assignedCat)}
      </div>
    `;
  }).join('');

  ccGrid.querySelectorAll('select.cc-assign[data-slot]').forEach(dd=>{
    dd.addEventListener('change', ()=>{
      const slot = String(dd.getAttribute('data-slot')||'');
      if(!slot) return;
      const next = String(dd.value||'');
      if(next){
        // Enforce uniqueness: selecting a used category clears it from the other slot.
        CARD_SLOTS.forEach(s=>{ if(s !== slot && cfg.slots[s] === next) cfg.slots[s] = null; });
      }
      cfg.slots[slot] = next || null;
      renderCardConfigModal(defs, cfg);
    });
  });

  ccGrid.querySelectorAll('input[type="checkbox"][data-mid][data-cat]').forEach(cb=>{
    cb.addEventListener('change', ()=>{
      const cat = cb.getAttribute('data-cat');
      const mid = cb.getAttribute('data-mid');
      if(!cat || !mid) return;
      const arr = cfg.categorySelected[cat] || (cfg.categorySelected[cat] = []);
      const i = arr.map(String).indexOf(String(mid));
      if(cb.checked){
        if(i === -1) arr.push(mid);
      }else{
        if(i !== -1) arr.splice(i, 1);
      }
    });
  });
}

async function showCardConfig(){
  const defs = await ensureCardDefs();
  __cardConfig = loadCardConfig(defs);
  renderCardConfigModal(defs, __cardConfig);
  openCardConfig();
}

function parseLocaleNumber(x){
  if(x == null) return NaN;
  if(typeof x === 'number') return x;
  let s = String(x).trim();
  if(!s) return NaN;
  s = s.replace(/\u00A0/g, ' ').replace(/\s+/g, '');
  // If both '.' and ',' exist, treat the last separator as the decimal separator.
  const lastDot = s.lastIndexOf('.');
  const lastComma = s.lastIndexOf(',');
  if(lastDot !== -1 && lastComma !== -1){
    if(lastComma > lastDot){
      // Danish-like: 1.234,56
      s = s.replace(/\./g, '').replace(/,/g, '.');
    }else{
      // US-like: 1,234.56
      s = s.replace(/,/g, '');
    }
  }else if(lastComma !== -1 && lastDot === -1){
    // Only comma present -> assume decimal comma.
    s = s.replace(/,/g, '.');
  }else{
    // Only dot present (or neither) -> Number() can handle.
  }
  const n = Number(s);
  return Number.isFinite(n) ? n : NaN;
}

function zToPercentile(z){
  const n = Number(z);
  if(!Number.isFinite(n)) return NaN;
  // Normal CDF approximation via erf
  const t = n / Math.sqrt(2);
  // Abramowitz-Stegun approximation for erf
  const sign = t < 0 ? -1 : 1;
  const a1=0.254829592, a2=-0.284496736, a3=1.421413741, a4=-1.453152027, a5=1.061405429, p=0.3275911;
  const x = Math.abs(t);
  const u = 1 / (1 + p*x);
  const y = 1 - (((((a5*u + a4)*u) + a3)*u + a2)*u + a1)*u*Math.exp(-x*x);
  const erf = sign * y;
  const cdf = 0.5 * (1 + erf);
  return cdf * 100;
}

function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

function hexToRgb(hex){
  try{
    let h = String(hex||'').trim();
    if(!h.startsWith('#')) return null;
    h = h.slice(1);
    if(h.length===3) h = h.split('').map(c=>c+c).join('');
    if(h.length!==6) return null;
    const r = parseInt(h.slice(0,2),16);
    const g = parseInt(h.slice(2,4),16);
    const b = parseInt(h.slice(4,6),16);
    if(!Number.isFinite(r)||!Number.isFinite(g)||!Number.isFinite(b)) return null;
    return {r,g,b};
  }catch(_){ return null; }
}

function mixHex(hexA, hexB, t){
  const a = hexToRgb(hexA);
  const b = hexToRgb(hexB);
  if(!a || !b) return hexA;
  const tt = clamp(Number(t)||0, 0, 1);
  const r = Math.round(a.r*(1-tt) + b.r*tt);
  const g = Math.round(a.g*(1-tt) + b.g*tt);
  const bb = Math.round(a.b*(1-tt) + b.b*tt);
  return `rgb(${r},${g},${bb})`;
}

function lerp(a,b,t){ return a*(1-t)+b*t; }
function mixRgb(rgbA, rgbB, t){
  const tt = clamp(Number(t)||0, 0, 1);
  return {
    r: Math.round(lerp(rgbA.r, rgbB.r, tt)),
    g: Math.round(lerp(rgbA.g, rgbB.g, tt)),
    b: Math.round(lerp(rgbA.b, rgbB.b, tt)),
  };
}
function pctToColor(pct){
  const p = clamp(Number(pct)||0, 0, 100);
  const red = {r:255,g:77,b:77};
  const white = {r:247,g:247,b:247};
  const blue = {r:77,g:163,b:255};
  if(p <= 50){
    const c = mixRgb(red, white, p/50);
    return `rgb(${c.r},${c.g},${c.b})`;
  }
  const c = mixRgb(white, blue, (p-50)/50);
  return `rgb(${c.r},${c.g},${c.b})`;
}

function fmtMetricValue(def, value, ratesSel){
  const v = Number(value);
  if(!Number.isFinite(v)) return '—';
  const cat = String(def?.category||'');
  const m = String(def?.metric||'');

  // NHL Edge formatting
  if(cat === 'Edge'){
    if(m.endsWith('Pctg')){
      return v.toFixed(1) + '%';
    }
    if(m === 'topShotSpeed' || m === 'avgShotSpeed' || m === 'maxSkatingSpeed' || m === 'distanceTotal or distancePer60'){
      return v.toFixed(1);
    }
  }

  if(m === 'ixG' || String(def?.name||'').trim().toLowerCase() === 'individual xg'){
    return v.toFixed(1);
  }

  if(m === 'GP') return String(Math.round(v));
  if(m === 'TOI'){
    return (ratesSel === 'PerGame') ? v.toFixed(2) : v.toFixed(1);
  }
  if(m.includes('%') || m === 'PDO' || (String(def?.name||'').includes('%'))){
    if(m === 'PDO') return v.toFixed(1);
    const s = (m.startsWith('d') && v > 0) ? '+' : '';
    return s + v.toFixed(1) + '%';
  }
  if(m.endsWith('+/-') || m.includes('+/-') || m === 'GAx' || m === 'GSAx' || m === 'xG+/-' || m === 'xG+/-' || m === 'C+/-' || m === 'F+/-' || m === 'S+/-' || m === 'G+/-'){
    const s = v > 0 ? '+' : '';
    return s + v.toFixed(2);
  }
  if(m.startsWith('RAPM')) return v.toFixed(3);
  if(cat === 'Context' && (m === 'QoT' || m === 'QoC' || m === 'ZS')) return v.toFixed(3);

  // counts / rates
  return (ratesSel === 'Totals') ? String(Math.round(v)) : v.toFixed(2);
}

function displayMetricLabel(def, labels){
  const m = String(def?.metric||'');
  if(m === 'iShots or iFenwick') return String(labels?.Attempts || def?.name || 'Attempts');
  if(m === 'Sh% or FSh%') return String(labels?.Sh || def?.name || 'Sh%');
  if(m === 'xSh% or xFS%' || m === 'xSh% or xFSh%') return String(labels?.xSh || def?.name || 'xSh%');
  if(m === 'dSh% or dFSh%') return String(labels?.dSh || def?.name || 'dSh%');
  return String(def?.name || def?.metric || def?.id || '');
}

function renderCardMetric(def, metric, labels, ratesSel){
  const pct = Number(metric?.pct);
  const pctOk = Number.isFinite(pct);
  const width = pctOk ? clamp(pct, 0, 100).toFixed(1) : '0.0';
  const color = pctOk ? pctToColor(pct) : 'rgba(255,255,255,0.15)';
  const valText = fmtMetricValue(def, metric?.value, ratesSel);
  return `
    <div class="metric">
      <div class="metric-head">
        <div class="metric-name">${displayMetricLabel(def, labels)}</div>
        <div class="metric-val">${valText}</div>
      </div>
      <div class="metric-bar"><div class="metric-fill" style="width:${width}%; background:${color};"></div></div>
    </div>
  `;
}

function renderCardUI(data, defs, cfg){
  if(!cardPanelInner) return;
  const metrics = data?.metrics || {};
  const labels = data?.labels || {};
  const ratesSel = String(cardRates?.value || data?.rates || 'Totals');

  const defsMetrics = Array.isArray(defs?.metrics) ? defs.metrics : [];
  const defById = {};
  defsMetrics.forEach(d=>{ if(d?.id) defById[String(d.id)] = d; });

  const defaultsByCat = {};
  defsMetrics.forEach(d=>{
    const cat = String(d?.category||'');
    if(!cat) return;
    const isDef = String(d?.default||'').trim()==='1' || d?.default===true || String(d?.default||'').toLowerCase()==='true';
    if(!isDef) return;
    (defaultsByCat[cat] = defaultsByCat[cat] || []).push(String(d?.id||''));
  });

  const slots = cfg?.slots || {};
  const selectedByCat = cfg?.categorySelected || {};

  function slotHtml(slot){
    const cat = slots?.[slot];
    if(!cat) return '';
    let mids = Array.isArray(selectedByCat?.[cat]) ? selectedByCat[cat].map(String).filter(Boolean) : [];
    if(!mids.length) mids = (defaultsByCat[cat] || []).filter(Boolean);
    const body = mids.map(mid=>{
      const def = defById[mid] || { id: mid, category: cat, metric: mid.split('|')[1] || mid, name: mid };
      let m = metrics?.[mid];
      // Special: TOI/GP display when rates is PerGame
      if(ratesSel === 'PerGame' && mid === 'Ice Time|TOI'){
        const toi = Number(metrics?.['Ice Time|TOI']?.value);
        const gp = Number(metrics?.['Ice Time|GP']?.value);
        if(Number.isFinite(toi) && Number.isFinite(gp) && gp > 0){
          m = { value: toi / gp, pct: metrics?.['Ice Time|TOI']?.pct };
        }
      }
      return renderCardMetric(def, m, labels, ratesSel);
    }).join('');
    return `<div class="card-slot"><h3>${cat}</h3>${body || '<div class="skater-empty" style="padding:10px 0;">No metrics selected.</div>'}</div>`;
  }

  const columns = [
    ['L1','L2','L3'],
    ['C1','C2','C3'],
    ['R1','R2','R3'],
  ];
  cardPanelInner.innerHTML = `
    <div class="card-grid">
      ${columns.map(col=>`<div class="card-col">${col.map(slotHtml).join('')}</div>`).join('')}
    </div>
  `;
}

async function loadCardPanel(){
  if(!cardPanelInner) return;
  if(!cardEnabled()){
    cardPanelInner.textContent = '';
    return;
  }

  updateCardSlicerSummary();
  const playerId = String(playerSelect?.value || '').trim();
  if(!playerId){
    cardPanelInner.textContent = 'Select a player to view Card.';
    return;
  }

  const season = String(seasonSelect?.value || '').trim() || '20252026';
  const scope = String(cardScope?.value || 'season');
  const seasonState = String(cardSeasonState?.value || 'regular');
  const strengthState = String(cardStrengthState?.value || '5v5');
  const rates = String(cardRates?.value || 'Totals');
  const xgModel = String(cardXgModel?.value || 'xG_F');
  let minGP = Number.parseInt(String(cardMinGp?.value || '0'), 10);
  if(!Number.isFinite(minGP) || minGP < 0) minGP = 0;
  let minTOI = Number(String(cardMinToi?.value || '0'));
  if(!Number.isFinite(minTOI) || minTOI < 0) minTOI = 0;

  cardPanelInner.textContent = 'Loading card...';
  try{
    const defs = await ensureCardDefs();
    const cfg = (__cardConfig = loadCardConfig(defs));
    // Build requested metric list from configured categories.
    const defsMetrics = Array.isArray(defs?.metrics) ? defs.metrics : [];
    const byCat = {};
    defsMetrics.forEach(m=>{
      const c = String(m?.category||'').trim();
      if(!c) return;
      (byCat[c] = byCat[c] || []).push(m);
    });
    const metricIds = [];
    const usedCats = new Set(Object.values(cfg?.slots||{}).filter(Boolean).map(String));
    usedCats.forEach(cat=>{
      let mids = Array.isArray(cfg?.categorySelected?.[cat]) ? cfg.categorySelected[cat].map(String).filter(Boolean) : [];
      if(!mids.length){
        const defaults = (byCat[cat] || []).filter(x=>String(x?.default||'').trim()==='1' || x?.default===true || String(x?.default||'').toLowerCase()==='true');
        mids = defaults.map(x=>String(x?.id||'')).filter(Boolean);
      }
      mids.forEach(id=>{ if(id && !metricIds.includes(id)) metricIds.push(id); });
    });
    // Ensure GP is present if we need TOI/GP display.
    if(String(rates) === 'PerGame' && metricIds.includes('Ice Time|TOI') && !metricIds.includes('Ice Time|GP')){
      metricIds.push('Ice Time|GP');
    }

    const url = `/api/skaters/card?season=${encodeURIComponent(season)}&playerId=${encodeURIComponent(playerId)}&seasonState=${encodeURIComponent(seasonState)}&strengthState=${encodeURIComponent(strengthState)}&xgModel=${encodeURIComponent(xgModel)}&rates=${encodeURIComponent(rates)}&scope=${encodeURIComponent(scope)}&minGP=${encodeURIComponent(String(minGP))}&minTOI=${encodeURIComponent(String(minTOI))}&metricIds=${encodeURIComponent(metricIds.join(','))}`;
    const r = await fetch(url, { cache: 'no-store' });
    let data = null;
    try{
      data = await r.json();
    }catch(_){
      data = null;
    }
    if(!r.ok){
      const err = (data && typeof data === 'object' && data.error) ? String(data.error) : '';
      cardPanelInner.textContent = `Error loading Card (${r.status}${err?`: ${err}`:''}).`;
      return;
    }
    if(data?.error){
      if(data.error === 'not_found'){
        cardPanelInner.textContent = 'No SeasonStats found for this filter.';
        return;
      }
      cardPanelInner.textContent = 'Error loading Card.';
      return;
    }
    renderCardUI(data, defs, cfg);
  }catch(e){
    try{ console.error('[card] loadCardPanel failed:', e); }catch(_){/*noop*/}
    cardPanelInner.textContent = 'Error loading Card.';
  }
}

// -----------------------------
// Table View (no Edge metrics)
// -----------------------------
const TABLE_CONFIG_KEY = 'nhlSkatersTableConfig_v1';
let __tableRows = [];
let __tableBusy = false;
let __tableLastKey = '';

const DEFAULT_TABLE_METRIC_IDS = [
  'Ice Time|GP',
  'Ice Time|TOI',
  'Production|iGoals',
  'Production|Assists1',
  'Production|Assists2',
  'Production|Points',
  'Defense|RAPM GA',
  'Defense|RAPM xGA',
  'Offense|RAPM GF',
  'Offense|RAPM xGF',
  'Play Driving|RAPM G+/-',
  'Play Driving|RAPM xG+/-',
  'Play Driving|CF%',
  'Play Driving|xGF%',
  'Play Driving|GF%',
  'Context|QoT',
  'Context|QoC',
  'Context|ZS',
  'Context|PDO',
  'Shooting|iShots or iFenwick',
  'Shooting|ixG',
  'Shooting|Sh% or FSh%',
  'Shooting|xSh% or xFSh%',
  'Shooting|dSh% or dFSh%',
  'Shooting|GAx',
];

function getTableConfig(){
  try{
    const raw = localStorage.getItem(TABLE_CONFIG_KEY);
    if(!raw) return null;
    const js = JSON.parse(raw);
    if(!js || !Array.isArray(js.metricIds)) return null;
    // Backward-compat: migrate old typo id to corrected id.
    try{
      js.metricIds = js.metricIds.map(id=> String(id) === 'Shooting|xSh% or xFS%' ? 'Shooting|xSh% or xFSh%' : id);
      if(String(js.sortMetricId||'') === 'Shooting|xSh% or xFS%') js.sortMetricId = 'Shooting|xSh% or xFSh%';
    }catch(_){/*noop*/}
    return js;
  }catch(_){
    return null;
  }
}

function saveTableConfig(cfg){
  try{ localStorage.setItem(TABLE_CONFIG_KEY, JSON.stringify(cfg)); }catch(_){/*noop*/}
}

function ensureTableConfig(){
  const cfg0 = getTableConfig();
  if(cfg0) return cfg0;
  const cfg = { version: 1, metricIds: DEFAULT_TABLE_METRIC_IDS.slice(), sortMetricId: 'Production|Points', sortDir: 'desc' };
  saveTableConfig(cfg);
  return cfg;
}

function isTableActive(){
  return !!tabTable?.classList.contains('active');
}

function __fmtTableValue(metricId, v){
  if(v == null) return '';
  const n = Number(v);
  if(!Number.isFinite(n)) return '';
  const ratesVal = String(cardRates?.value || 'Totals');
  const parts = String(metricId||'').split('|');
  const m = String(parts[1]||parts[0]||'');
  const isXgLike = /(^|[^A-Za-z])xG|ixG|xGF|xGA|GAx|GSAx/i.test(m);
  const isPercent = m.includes('%') || m === 'PDO' || m === 'Sv%' || m === 'Sh%';
  if(m === 'GP') return String(Math.round(n));
  if(m === 'TOI') return String(Math.round(n));
  if(isPercent) return n.toFixed(1);
  if(m.startsWith('RAPM')) return n.toFixed(3);
  if(m === 'QoT' || m === 'QoC' || m === 'ZS') return n.toFixed(3);
  if(ratesVal === 'Totals'){
    if(isXgLike) return n.toFixed(2);
    return String(Math.round(n));
  }
  return (Math.abs(n) >= 1000) ? n.toFixed(0) : n.toFixed(2);
}

async function fetchTablePlayers(season, seasonState){
  const url = `/api/skaters/players?scope=league&season=${encodeURIComponent(season)}&seasonState=${encodeURIComponent(seasonState)}`;
  const r = await fetch(url, { cache:'no-store' });
  const js = await r.json();
  const list = Array.isArray(js?.players) ? js.players : [];
  return list
    .map(p=>({ playerId: Number(p?.playerId), name: String(p?.name||''), pos: String(p?.pos||''), team: String(p?.team||'') }))
    .filter(p=>Number.isFinite(p.playerId) && p.playerId > 0);
}

function __tableKey(obj){
  try{ return JSON.stringify(obj); }catch(_){ return String(Date.now()); }
}

function __setTableError(text){
  if(!tableError) return;
  const t = String(text||'');
  tableError.textContent = t;
  tableError.style.display = t ? '' : 'none';
}

function renderTable(cfg, defs){
  if(!skatersTable) return;
  const metricIds = Array.isArray(cfg?.metricIds) ? cfg.metricIds.map(String).filter(Boolean) : [];
  const sortId = String(cfg?.sortMetricId || 'Production|Points');
  const dir = (String(cfg?.sortDir||'desc') === 'asc') ? 'asc' : 'desc';

  const byId = {};
  (Array.isArray(defs?.metrics) ? defs.metrics : []).forEach(m=>{
    const id = String(m?.id||'');
    if(id) byId[id] = m;
  });

  const rows = __tableRows.slice();
  rows.sort((a,b)=>{
    const av = Number(a?.metrics?.[sortId]);
    const bv = Number(b?.metrics?.[sortId]);
    const aOk = Number.isFinite(av);
    const bOk = Number.isFinite(bv);
    if(aOk && bOk && av !== bv) return (dir === 'asc') ? (av - bv) : (bv - av);
    if(aOk !== bOk) return aOk ? -1 : 1;
    return String(a?.name||'').localeCompare(String(b?.name||''));
  });

  const head = [];
  head.push('<tr>');
  head.push('<th class="rank">Rank</th>');
  head.push('<th class="name">Name</th>');
  head.push('<th class="pos">Pos</th>');
  for(const id of metricIds){
    const def = byId[id];
    const label = String(metricLabel(id) || def?.name || id);
    const isSorted = (id === sortId);
    const arrow = isSorted ? (dir === 'asc' ? ' ▲' : ' ▼') : '';
    head.push(`<th data-mid="${escapeHtml(id)}">${escapeHtml(label)}${arrow}</th>`);
  }
  head.push('</tr>');

  let rank = 1;
  const body = [];
  const selectedPid = String(playerSelect?.value||'');
  for(const r of rows){
    const isSel = selectedPid && String(r.playerId) === selectedPid;
    body.push(`<tr data-pid="${escapeHtml(String(r.playerId))}" data-team="${escapeHtml(String(r.team||''))}"${isSel?` style="background: var(--league-highlight-color, rgba(77,163,255,0.12));"`:''}>`);
    body.push(`<td class="rank">${rank++}</td>`);
    body.push(`<td class="name">${escapeHtml(String(r.name||r.playerId))}</td>`);
    body.push(`<td class="pos">${escapeHtml(String(r.pos||''))}</td>`);
    for(const id of metricIds){
      body.push(`<td>${escapeHtml(__fmtTableValue(id, r.metrics?.[id]))}</td>`);
    }
    body.push('</tr>');
  }

  skatersTable.innerHTML = `<thead>${head.join('')}</thead><tbody>${body.join('')}</tbody>`;

  try{
    skatersTable.querySelectorAll('thead th[data-mid]').forEach(th=>{      const mid = String(th.getAttribute('data-mid')||'');
      if(!mid) return;
      th.addEventListener('click', ()=>{
        const cfg = ensureTableConfig();
        const newDir = (cfg.sortMetricId === mid && cfg.sortDir === 'desc') ? 'asc' : 'desc';
        saveTableConfig({ ...cfg, sortMetricId: mid, sortDir: newDir });
        __tableLastKey = '';
        loadTablePanel();
      });
    });
    skatersTable.querySelectorAll('tbody tr[data-pid]').forEach(tr=>{
      tr.addEventListener('click', async ()=>{
        const pid = String(tr.getAttribute('data-pid')||'');
        if(!pid) return;
        if(playerSelect && Array.from(playerSelect.options).some(o=>String(o.value)===pid)){
          playerSelect.value = pid;
          playerSelect.dispatchEvent(new Event('change'));
          return;
        }

        const team = String(tr.getAttribute('data-team')||'').toUpperCase();
        if(teamSelect && team && Array.from(teamSelect.options).some(o=>String(o.value).toUpperCase()===team)){
          teamSelect.value = team;
          teamSelect.dispatchEvent(new Event('change'));
          try{ await loadPlayers(); }catch(_){/*noop*/}
          if(playerSelect && Array.from(playerSelect.options).some(o=>String(o.value)===pid)){
            playerSelect.value = pid;
            playerSelect.dispatchEvent(new Event('change'));
          }
        }
      });
    });
  }catch(_){/*noop*/}
}

async function loadTablePanel(){
  if(!tabPanelTable || !isTableActive()) return;
  if(__tableBusy) return;

  const team = String(teamSelect?.value||'').trim();
  const season = String(seasonSelect?.value||'').trim() || '20252026';
  const seasonState = String(cardSeasonState?.value||'regular');
  const strengthState = String(cardStrengthState?.value||'5v5');
  const rates = String(cardRates?.value||'Totals');
  const xgModel = String(cardXgModel?.value||'xG_F');
  const scope = String(cardScope?.value||'season');
  let minGP = Number.parseInt(String(cardMinGp?.value||'0'), 10);
  if(!Number.isFinite(minGP) || minGP < 0) minGP = 0;
  let minTOI = Number(String(cardMinToi?.value||'0'));
  if(!Number.isFinite(minTOI) || minTOI < 0) minTOI = 0;

  if(tableSlicerSummary) tableSlicerSummary.textContent = String(cardSlicerSummary?.textContent||'');

  const defs = await ensureCardDefs();
  const cfg0 = ensureTableConfig();
  const metricIds = (Array.isArray(cfg0.metricIds)?cfg0.metricIds:[]).map(String).filter(id=>id && !id.startsWith('Edge|'));
  const sortMetricId = String(cfg0.sortMetricId||'Production|Points');
  const sortDir = (String(cfg0.sortDir||'desc') === 'asc') ? 'asc' : 'desc';
  const cfg = { ...cfg0, metricIds, sortMetricId, sortDir };
  if(metricIds.length === 0){
    if(skatersTable) skatersTable.innerHTML = '';
    __setTableError('No table metrics selected.');
    return;
  }

  const key = __tableKey({ season, seasonState, strengthState, rates, xgModel, scope, minGP, minTOI, metricIds, sortMetricId, sortDir });
  if(key === __tableLastKey && __tableRows.length){
    renderTable(cfg, defs);
    return;
  }

  __tableBusy = true;
  __tableLastKey = key;
  try{
    __setTableError('');
    if(tableLoading) tableLoading.style.display = '';

    const playersAll = await fetchTablePlayers(season, seasonState);
    const playerIds = playersAll.map(p=>p.playerId);
    if(!playerIds.length){
      __tableRows = [];
      if(skatersTable) skatersTable.innerHTML = '';
      __setTableError('No players found for this season/season state.');
      return;
    }

    const r = await fetch('/api/skaters/table', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      cache: 'no-store',
      body: JSON.stringify({
        season,
        seasonState,
        strengthState,
        xgModel,
        rates,
        scope,
        minGP,
        minTOI,
        playerIds,
        metricIds,
      }),
    });
    const js = await r.json();
    if(!r.ok || js?.error){
      const msg = String(js?.error || `${r.status} ${r.statusText}`);
      __setTableError(`Error loading table: ${msg}`);
      return;
    }

    const byPid = {};
    (Array.isArray(js?.players) ? js.players : []).forEach(p=>{
      const pid = Number(p?.playerId);
      if(Number.isFinite(pid) && pid > 0) byPid[String(pid)] = (p.metrics && typeof p.metrics === 'object') ? p.metrics : {};
    });

    const eligiblePidSet = new Set(Object.keys(byPid));
    const players = playersAll.filter(p=> eligiblePidSet.has(String(p.playerId)));

    __tableRows = players.map(p=>({
      playerId: p.playerId,
      name: p.name,
      pos: p.pos,
      team: p.team,
      metrics: byPid[String(p.playerId)] || {},
    }));

    renderTable(cfg, defs);
  }catch(e){
    try{ console.error('[table] loadTablePanel failed:', e); }catch(_){/*noop*/}
    __setTableError('Error loading table.');
  }finally{
    if(tableLoading) tableLoading.style.display = 'none';
    __tableBusy = false;
  }
}

function __csvEscape(v){
  const s = (v == null) ? '' : String(v);
  return /[",\n\r]/.test(s) ? '"' + s.replace(/"/g, '""') + '"' : s;
}

async function exportTableCsv(){
  const defs = await ensureCardDefs();
  const cfg0 = ensureTableConfig();
  const metricIds = (Array.isArray(cfg0.metricIds)?cfg0.metricIds:[]).map(String).filter(id=>id && !id.startsWith('Edge|'));
  const sortMetricId = String(cfg0.sortMetricId||'Production|Points');
  const sortDir = (String(cfg0.sortDir||'desc') === 'asc') ? 'asc' : 'desc';

  const byId = {};
  (Array.isArray(defs?.metrics) ? defs.metrics : []).forEach(m=>{
    const id = String(m?.id||'');
    if(id) byId[id] = m;
  });

  const rows = __tableRows.slice();
  rows.sort((a,b)=>{
    const av = Number(a?.metrics?.[sortMetricId]);
    const bv = Number(b?.metrics?.[sortMetricId]);
    const aOk = Number.isFinite(av);
    const bOk = Number.isFinite(bv);
    if(aOk && bOk && av !== bv) return (sortDir === 'asc') ? (av - bv) : (bv - av);
    if(aOk !== bOk) return aOk ? -1 : 1;
    return String(a?.name||'').localeCompare(String(b?.name||''));
  });

  const header = ['Rank','Name','Pos'].concat(metricIds.map(id=>{
    const def = byId[id];
    return String(metricLabel(id) || def?.name || id);
  }));

  const lines = [];
  lines.push(header.map(__csvEscape).join(','));
  let rank = 1;
  for(const r of rows){
    const row = [
      String(rank++),
      String(r?.name||r?.playerId||''),
      String(r?.pos||''),
      ...metricIds.map(id=>__fmtTableValue(id, r?.metrics?.[id]))
    ];
    lines.push(row.map(__csvEscape).join(','));
  }

  const season = String(seasonSelect?.value||'').trim() || '20252026';
  const seasonState = String(cardSeasonState?.value||'regular');
  const strengthState = String(cardStrengthState?.value||'5v5');
  downloadTextFile(`skaters_table_${season}_${seasonState}_${strengthState}.csv`, lines.join('\n'), 'text/csv;charset=utf-8;');
}

function openTableConfig(){
  if(tableConfigModal) tableConfigModal.hidden = false;
}

function closeTableConfig(){
  if(tableConfigModal) tableConfigModal.hidden = true;
}

function __setTableConfigStatus(text){
  if(tableConfigStatus) tableConfigStatus.textContent = String(text||'');
}

async function showTableConfig(){
  const defs = await ensureCardDefs();
  const metricsAll = Array.isArray(defs?.metrics) ? defs.metrics : [];
  const metrics = metricsAll.filter(m=> String(m?.category||'') !== 'Edge' && !String(m?.id||'').startsWith('Edge|'));
  const cfg = ensureTableConfig();
  const selected = new Set((Array.isArray(cfg.metricIds)?cfg.metricIds:[]).map(String).filter(Boolean));
  Array.from(selected).forEach(id=>{ if(id.startsWith('Edge|')) selected.delete(id); });

  const byCat = {};
  metrics.forEach(m=>{
    const c = String(m?.category||'Other').trim() || 'Other';
    (byCat[c] = byCat[c] || []).push(m);
  });
  const cats = Object.keys(byCat).sort((a,b)=>a.localeCompare(b));
  if(tableMetricPicker){
    tableMetricPicker.innerHTML = cats.map(cat=>{
      const items = (byCat[cat]||[]).map(m=>{
        const id = String(m?.id||'');
        const label = String(metricLabel(id)||m?.name||id);
        const checked = selected.has(id) ? 'checked' : '';
        return `<label class="table-metric"><input type="checkbox" data-mid="${escapeHtml(id)}" ${checked}/> <span>${escapeHtml(label)}</span></label>`;
      }).join('');
      return `<div class="table-metric-group"><div class="t">${escapeHtml(cat)}</div><div class="table-metrics-grid">${items}</div></div>`;
    }).join('');

    tableMetricPicker.querySelectorAll('input[type="checkbox"][data-mid]').forEach(cb=>{
      cb.addEventListener('change', ()=>{
        const id = String(cb.getAttribute('data-mid')||'');
        if(!id) return;
        if(cb.checked) selected.add(id);
        else selected.delete(id);
        __setTableConfigStatus(`${selected.size} selected`);
      });
    });
  }

  __setTableConfigStatus(`${selected.size} selected`);
  openTableConfig();

  if(btnTableDefaults){
    btnTableDefaults.onclick = ()=>{
      selected.clear();
      DEFAULT_TABLE_METRIC_IDS.forEach(id=>selected.add(id));
      try{ tableMetricPicker?.querySelectorAll('input[type="checkbox"][data-mid]').forEach(cb=>{ cb.checked = selected.has(String(cb.getAttribute('data-mid')||'')); }); }catch(_){/*noop*/}
      __setTableConfigStatus(`${selected.size} selected`);
    };
  }
  if(btnTableNone){
    btnTableNone.onclick = ()=>{
      selected.clear();
      try{ tableMetricPicker?.querySelectorAll('input[type="checkbox"][data-mid]').forEach(cb=>{ cb.checked = false; }); }catch(_){/*noop*/}
      __setTableConfigStatus(`${selected.size} selected`);
    };
  }
  if(btnTableCardDefaults){
    btnTableCardDefaults.onclick = ()=>{
      selected.clear();
      metrics.forEach(m=>{
        const id = String(m?.id||'');
        const d = (String(m?.default||'').trim()==='1' || m?.default===true || String(m?.default||'').toLowerCase()==='true');
        if(id && d) selected.add(id);
      });
      try{ tableMetricPicker?.querySelectorAll('input[type="checkbox"][data-mid]').forEach(cb=>{ cb.checked = selected.has(String(cb.getAttribute('data-mid')||'')); }); }catch(_){/*noop*/}
      __setTableConfigStatus(`${selected.size} selected`);
    };
  }

  if(btnApplyTableConfig){
    btnApplyTableConfig.onclick = ()=>{
      const metricIds = Array.from(selected.values()).filter(id=>id && !id.startsWith('Edge|'));
      const existingCfg = ensureTableConfig();
      const next = {
        version: 1,
        metricIds,
        sortMetricId: String(existingCfg.sortMetricId || metricIds[0] || 'Production|Points'),
        sortDir: String(existingCfg.sortDir || 'desc'),
      };
      saveTableConfig(next);
      __tableLastKey = '';
      closeTableConfig();
      loadTablePanel();
    };
  }
}

function themeAccent(){
  try{ return getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#4da3ff'; }catch(_){ return '#4da3ff'; }
}

function themeTextDim(){
  try{ return getComputedStyle(document.documentElement).getPropertyValue('--text-dim').trim() || '#9aa4b1'; }catch(_){ return '#9aa4b1'; }
}

function fmt3(x){
  const n = Number(x);
  if(!Number.isFinite(n)) return '';
  return n.toFixed(3);
}

function pctRank(values, v){
  const arr = (values||[]).filter(n=>Number.isFinite(n)).slice().sort((a,b)=>a-b);
  if(!arr.length || !Number.isFinite(v)) return null;
  if(arr.length === 1) return 50;
  let lo = 0, hi = arr.length;
  while(lo < hi){
    const mid = (lo+hi)>>1;
    if(arr[mid] <= v) lo = mid + 1;
    else hi = mid;
  }
  const rank = lo - 1;
  return 100 * (rank / (arr.length - 1));
}

function setActiveProjSubtab(which){
  const isP = which === 'player';
  const isT = which === 'team';
  const isL = which === 'league';
  projTabPlayer?.classList.toggle('active', isP);
  projTabTeam?.classList.toggle('active', isT);
  projTabLeague?.classList.toggle('active', isL);
  projTabPlayer?.setAttribute('aria-selected', isP ? 'true' : 'false');
  projTabTeam?.setAttribute('aria-selected', isT ? 'true' : 'false');
  projTabLeague?.setAttribute('aria-selected', isL ? 'true' : 'false');
  if(projPanelPlayer) projPanelPlayer.hidden = !isP;
  if(projPanelTeam) projPanelTeam.hidden = !isT;
  if(projPanelLeague) projPanelLeague.hidden = !isL;
}

async function ensureProjLeaguePlayers(){
  if(__projLeaguePlayers) return __projLeaguePlayers;
  let js = null;
  try{
    const r = await fetch('/api/player-projections/league', { cache:'no-store' });
    if(!r.ok){
      console.error('[projections] /api/player-projections/league failed:', r.status);
      __projLeaguePlayers = [];
      return __projLeaguePlayers;
    }
    js = await r.json();
  }catch(e){
    console.error('[projections] /api/player-projections/league failed:', e);
    __projLeaguePlayers = [];
    return __projLeaguePlayers;
  }
  __projLeaguePlayers = Array.isArray(js?.players) ? js.players : [];
  // Debug: log team distribution
  const teamCounts = {};
  __projLeaguePlayers.forEach(p => {
    const t = p.team || '(no team)';
    teamCounts[t] = (teamCounts[t] || 0) + 1;
  });
  console.log('[projections] League players by team:', teamCounts);
  console.log('[projections] Total players loaded:', __projLeaguePlayers.length);
  return __projLeaguePlayers;
}

function renderPlayerKpisFromLeague(p, ctx){
  if(!projPlayerKpis) return;
  if(!p){
    projPlayerKpis.innerHTML = '<div class="skater-empty" style="grid-column:1 / -1; padding:8px 2px;">Select a player to view projections.</div>';
    return;
  }
  const items = [
    ['Position', p.position],
    ['GP', p.gp],
    ['Age', fmt3(p.Age)],
    ['Rookie', fmt3(p.Rookie)],
    ['EVO', fmt3(p.EVO)],
    ['EVD', fmt3(p.EVD)],
    ['PP', fmt3(p.PP)],
    ['SH', fmt3(p.SH)],
    ['QoT', ctx?.QoT != null ? fmt3(ctx.QoT) : '—'],
    ['QoC', ctx?.QoC != null ? fmt3(ctx.QoC) : '—'],
    ['ZS', ctx?.ZS != null ? fmt3(ctx.ZS) : '—'],
    ['Total', fmt3(p.total)],
  ];
  projPlayerKpis.innerHTML = items.map(([k,v])=>(
    `<div class="kpi-card"><div class="kpi-title">${k}</div><div class="kpi-value">${(v==null||v==='')?'—':v}</div></div>`
  )).join('');
}

function renderPlayerRadarFromLeague(p, leaguePlayers, contextData, teamColor){
  const ctx = document.getElementById('projPlayerRadar')?.getContext('2d');
  if(!ctx) return;
  if(__projRadarChart){ try{ __projRadarChart.destroy(); }catch(_){/*noop*/} __projRadarChart=null; }
  if(!p) return;

  const metrics = ['EVO','EVD','PP','SH','QoT','QoC','ZS'];
  const groupPos = String(p.position||'F').toUpperCase().startsWith('D') ? 'D' : 'F';
  const pool = (leaguePlayers||[]).filter(x=>String(x.position||'').toUpperCase().startsWith(groupPos));
  const valuesByMetric = {};
  for(const m of metrics){ 
    if(m === 'QoT' || m === 'QoC' || m === 'ZS'){
      valuesByMetric[m] = pool.map(x=>Number(x.contextData?.[m]));
    } else {
      valuesByMetric[m] = pool.map(x=>Number(x[m]));
    }
  }
  const pct = metrics.map(m=>{
    let v;
    if(m === 'QoT' || m === 'QoC' || m === 'ZS'){
      v = Number(contextData?.[m]);
    } else {
      v = Number(p[m]);
    }
    const pr = pctRank(valuesByMetric[m], v);
    return pr==null ? 0 : pr;
  });

  const accent = teamColor || themeAccent();
  const grid = 'rgba(154,164,177,0.16)';
  const tick = themeTextDim();

  __projRadarChart = new Chart(ctx, {
    type: 'radar',
    data: {
      labels: metrics,
      datasets: [{
        label: `${p.name || p.playerId} (${groupPos})`,
        data: pct,
        borderColor: mixHex(accent, '#ffffff', 0.10),
        backgroundColor: mixHex(accent, '#ffffff', 0.35),
        pointBackgroundColor: mixHex(accent, '#ffffff', 0.10),
        pointRadius: 3,
        borderWidth: 2,
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      interaction: {
        mode: 'nearest',
        intersect: false,
      },
      plugins: {
        legend: { labels: { color: tick, font: { size: 13, weight:'700' } } },
        tooltip: { 
          callbacks: { 
            title: () => '',
            label: (ctx) => '',
            afterBody: (items) => {
              if(!items || !items[0]) return '';
              return metrics.map((m, i) => `${m}: ${pct[i].toFixed(1)}%`);
            }
          } 
        }
      },
      scales: {
        r: {
          min: 0,
          max: 100,
          ticks: { display: false },
          grid: { color: grid },
          angleLines: { color: grid },
          pointLabels: { color: tick, font: { size: 12, weight:'800' } },
        }
      }
    }
  });
}

function renderTeamStackFromLeague(team, leaguePlayers, teamColor){
  const ctx = document.getElementById('projTeamStack')?.getContext('2d');
  if(!ctx) return;
  if(__projTeamChart){ try{ __projTeamChart.destroy(); }catch(_){/*noop*/} __projTeamChart=null; }

  const list = (leaguePlayers||[])
    .filter(p=>String(p.team||'').toUpperCase() === String(team||'').toUpperCase())
    .slice()
    .sort((a,b)=>Number(b.total||0)-Number(a.total||0));

  const labels = list.map(p=>p.name || String(p.playerId));
  const metrics = ['Age','Rookie','EVO','EVD','PP','SH'];
  const accent = teamColor || themeAccent();
  const tick = themeTextDim();
  const grid = 'rgba(154,164,177,0.14)';

  const colors = [
    mixHex(accent,'#ffffff',0.05),
    mixHex(accent,'#ffffff',0.18),
    mixHex(accent,'#ffffff',0.32),
    mixHex(accent,'#ffffff',0.46),
    mixHex(accent,'#ffffff',0.60),
    mixHex(accent,'#ffffff',0.74),
  ];

  const datasets = metrics.map((m, idx)=>({
    label: m,
    data: list.map(p=>Number(p[m]||0)),
    backgroundColor: colors[idx % colors.length],
    borderColor: 'rgba(255,255,255,0.10)',
    borderWidth: 1,
  }));

  __projTeamChart = new Chart(ctx, {
    type: 'bar',
    data: { labels, datasets },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      indexAxis: 'y',
      plugins: {
        legend: { labels: { color: tick, font:{ size: 12, weight:'800' } } },
        tooltip: { callbacks: { footer: (items)=>{
          const i = items?.[0]?.dataIndex;
          if(i==null) return '';
          const t = Number(list[i]?.total);
          return Number.isFinite(t) ? `Total: ${t.toFixed(3)}` : '';
        } } }
      },
      scales: {
        x: { stacked: true, ticks: { color: tick }, grid: { color: grid } },
        y: { stacked: true, ticks: { color: tick, autoSkip: false }, grid: { display:false } },
      }
    }
  });
}

function renderLeagueTable(players, selectedPlayerId){
  if(!projLeagueTable) return;
  const cols = [
    { key:'rank', label:'Rank', num:true },
    { key:'name', label:'Player', name:true },
    { key:'team', label:'Team' },
    { key:'position', label:'Pos' },
    { key:'gp', label:'GP', num:true },
    { key:'Age', label:'Age', num:true },
    { key:'Rookie', label:'Rookie', num:true },
    { key:'EVO', label:'EVO', num:true },
    { key:'EVD', label:'EVD', num:true },
    { key:'PP', label:'PP', num:true },
    { key:'SH', label:'SH', num:true },
    { key:'QoT', label:'QoT', num:true },
    { key:'QoC', label:'QoC', num:true },
    { key:'ZS', label:'ZS', num:true },
    { key:'total', label:'Total', num:true },
  ];

  const sortKey = __projLeagueSort.key;
  const sortDir = __projLeagueSort.dir;
  const list = (players||[]).filter(p=>p.name && String(p.name).trim()).slice();
  list.sort((a,b)=>{
    const av = a?.[sortKey];
    const bv = b?.[sortKey];
    const an = Number(av);
    const bn = Number(bv);
    let cmp = 0;
    if(Number.isFinite(an) && Number.isFinite(bn)) cmp = an - bn;
    else cmp = String(av||'').localeCompare(String(bv||''));
    return sortDir==='asc' ? cmp : -cmp;
  });

  // Add rank based on sorted position
  list.forEach((p, i) => { p._rank = i + 1; });

  const head = `<thead><tr>${cols.map(c=>{
    const active = c.key === sortKey;
    const ind = active ? `<span class="sort-ind">${sortDir==='asc'?'▲':'▼'}</span>` : '';
    const cls = c.name ? 'name' : (c.num ? 'num' : '');
    return `<th class="${cls}" data-key="${c.key}">${c.label}${ind}</th>`;
  }).join('')}</tr></thead>`;

  const body = `<tbody>${list.map(p=>{
    const isSelected = String(p.playerId) === String(selectedPlayerId||'');
    const rowCls = isSelected ? ' class="selected-player"' : '';
    const td = (val, num, isName)=>{
      if(num){
        const n = Number(val);
        const s = Number.isFinite(n) ? (Number.isInteger(n) ? String(n) : n.toFixed(3)) : '';
        return `<td class="num">${s || '—'}</td>`;
      }
      if(isName){
        return `<td class="name">${(val==null||val==='')?'—':String(val)}</td>`;
      }
      return `<td>${(val==null||val==='')?'—':String(val)}</td>`;
    };
    return `<tr${rowCls}>
      ${td(p._rank,true,false)}
      ${td(p.name,false,true)}
      ${td(p.team,false,false)}
      ${td(p.position,false,false)}
      ${td(p.gp,true,false)}
      ${td(p.Age,true,false)}
      ${td(p.Rookie,true,false)}
      ${td(p.EVO,true,false)}
      ${td(p.EVD,true,false)}
      ${td(p.PP,true,false)}
      ${td(p.SH,true,false)}
      ${td(p.contextData?.QoT,true,false)}
      ${td(p.contextData?.QoC,true,false)}
      ${td(p.contextData?.ZS,true,false)}
      ${td(p.total,true,false)}
    </tr>`;
  }).join('')}</tbody>`;

  projLeagueTable.innerHTML = head + body;
  projLeagueTable.querySelectorAll('th[data-key]').forEach(th=>{
    th.addEventListener('click', ()=>{
      const k = th.getAttribute('data-key');
      if(!k) return;
      if(__projLeagueSort.key === k){
        __projLeagueSort.dir = (__projLeagueSort.dir === 'asc') ? 'desc' : 'asc';
      }else{
        __projLeagueSort.key = k;
        __projLeagueSort.dir = k === 'name' || k === 'team' || k === 'position' ? 'asc' : 'desc';
      }
      renderLeagueTable(__projLeaguePlayers, playerSelect?.value);
    });
  });
}

function getAccentColor(){
  try{
    return getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#4da3ff';
  }catch(e){
    return '#4da3ff';
  }
}

function hexToRgb(hex){
  const s = String(hex||'').trim().replace('#','');
  if(s.length !== 6) return null;
  const r = parseInt(s.slice(0,2),16);
  const g = parseInt(s.slice(2,4),16);
  const b = parseInt(s.slice(4,6),16);
  if(!Number.isFinite(r) || !Number.isFinite(g) || !Number.isFinite(b)) return null;
  return {r,g,b};
}

function lerp(a,b,t){ return a + (b-a)*t; }

function percentileToColor(pct){
  const p = clamp(Number(pct), 0, 100);
  const red = hexToRgb('#ff6a6a');
  const white = hexToRgb('#f1f5f9');
  const blue = hexToRgb('#4da3ff');
  if(!red || !white || !blue) return getAccentColor();
  if(p <= 50){
    const t = p / 50;
    const r = Math.round(lerp(red.r, white.r, t));
    const g = Math.round(lerp(red.g, white.g, t));
    const b = Math.round(lerp(red.b, white.b, t));
    return `rgb(${r},${g},${b})`;
  }
  const t = (p - 50) / 50;
  const r = Math.round(lerp(white.r, blue.r, t));
  const g = Math.round(lerp(white.g, blue.g, t));
  const b = Math.round(lerp(white.b, blue.b, t));
  return `rgb(${r},${g},${b})`;
}

function normRatesTotals(v){
  const s = String(v || '').trim().toLowerCase();
  if(s.startsWith('tot')) return 'Totals';
  if(s.startsWith('rate')) return 'Rates';
  return v;
}

function pickRow(rows, ratesTotals){
  const want = normRatesTotals(ratesTotals);
  // Prefer 5v5 row since it carries PP/SH columns too
  let r = rows.find(x => String(x.StrengthState||'') === '5v5' && normRatesTotals(x.Rates_Totals) === want);
  if(!r) r = rows.find(x => normRatesTotals(x.Rates_Totals) === want);
  if(!r) r = rows[0];
  return r || null;
}

function pickStrengthRow(rows, strength, ratesTotals){
  const want = normRatesTotals(ratesTotals);
  return rows.find(x => String(x.StrengthState||'') === strength && normRatesTotals(x.Rates_Totals) === want) || null;
}

function pickCtxRow(rows, strength){
  return rows.find(x => String(x.StrengthState||'') === strength) || null;
}

function applyRAPMSelectTextColor(){
  if(!teamSelect) return;
  const c = getComputedStyle(teamSelect).color;
  ['rapmPeriod','rapmCareerStrength','rapmMetric','rapmRatesTotals','rapmOutput','rapmZRange'].forEach(id=>{
    const el = document.getElementById(id);
    if(el) el.style.color = c;
  });
}

function applyExportButtonTextColor(){
  if(!teamSelect || !projExportCsv) return;
  const c = getComputedStyle(teamSelect).color;
  projExportCsv.style.color = c;
}

function clamp(v, lo, hi){
  return Math.max(lo, Math.min(hi, v));
}

function buildBarsFromRows(row5, rowPP, rowSH, opts){
  const metric = opts.metric;
  const output = opts.output;
  const pct = opts.percentiles || null;

  if(output === 'pct' && pct){
    return {
      fivev5: [
        { key: '5v5_off', label: 'Off', value: pct['5v5_off'] },
        { key: '5v5_def', label: 'Def', value: pct['5v5_def'] },
        { key: '5v5_diff', label: 'Diff', value: pct['5v5_diff'] },
      ],
      pp: [
        { key: 'pp_off', label: 'Off', value: pct['pp_off'] },
      ],
      sh: [
        { key: 'sh_def', label: 'Def', value: pct['sh_def'] },
      ],
    };
  }

  function getValue(row, colOrCols, invert=false){
    const cols = Array.isArray(colOrCols) ? colOrCols : [colOrCols];
    for(const col of cols){
      const n = parseLocaleNumber(row?.[col]);
      if(Number.isFinite(n)) return invert ? -n : n;
    }
    return NaN;
  }
  function getZ(row, colOrCols, invert=false){
    const cols = Array.isArray(colOrCols) ? colOrCols : [colOrCols];
    for(const col of cols){
      const n = parseLocaleNumber(row?.[col]);
      if(Number.isFinite(n)) return invert ? -n : n;
    }
    return NaN;
  }

  const map = {
    corsi: {
      off: ['CF', 'CF_zscore', false],
      def: ['CA', 'CA_zscore', true],
      diff: ['C_plusminus', 'C_plusminus_zscore', false],
      pp: [['PP_CF', 'CF'], ['PP_CF_zscore', 'CF_zscore'], false],
      sh: [['SH_CA', 'CA'], ['SH_CA_zscore', 'CA_zscore'], true],
    },
    xg: {
      off: ['xGF', 'xGF_zscore', false],
      def: ['xGA', 'xGA_zscore', true],
      diff: ['xG_plusminus', 'xG_plusminus_zscore', false],
      pp: [['PP_xGF', 'xGF'], ['PP_xGF_zscore', 'xGF_zscore'], false],
      sh: [['SH_xGA', 'xGA'], ['SH_xGA_zscore', 'xGA_zscore'], true],
    },
    goals: {
      off: ['GF', 'GF_zscore', false],
      def: ['GA', 'GA_zscore', true],
      diff: ['G_plusminus', 'G_plusminus_zscore', false],
      pp: [['PP_GF', 'GF'], ['PP_GF_zscore', 'GF_zscore'], false],
      sh: [['SH_GA', 'GA'], ['SH_GA_zscore', 'GA_zscore'], true],
    }
  };
  const m = map[metric] || map.corsi;

  function get(row, col, zcol, invert){
    if(output === 'z') return getZ(row, zcol, invert);
    if(output === 'pct'){
      const z = getZ(row, zcol, invert);
      const p = zToPercentile(z);
      return p;
    }
    return getValue(row, col, invert);
  }

  return {
    fivev5: [
      { key: '5v5_off', label: 'Off', value: get(row5, ...m.off) },
      { key: '5v5_def', label: 'Def', value: get(row5, ...m.def) },
      { key: '5v5_diff', label: 'Diff', value: get(row5, ...m.diff) },
    ],
    pp: [
      { key: 'pp_off', label: 'Off', value: get(rowPP, ...m.pp) },
    ],
    sh: [
      { key: 'sh_def', label: 'Def', value: get(rowSH, ...m.sh) },
    ],
  };
}

function renderBarSection(title, bars, scale){
  const axis = (()=>{
    if(scale.mode === 'pct'){
      return { min: 0, max: 100, midPct: 50, topLabel: '100', midLabel: '50', botLabel: '0' };
    }
    const min = Number(scale.min);
    const max = Number(scale.max);
    if(!Number.isFinite(min) || !Number.isFinite(max) || min === max){
      const r = Number.isFinite(scale.range) ? Number(scale.range) : 2;
      return { min: -r, max: r, zeroPct: 50, topLabel: fmtNum(r, 2), midLabel: '0', botLabel: fmtNum(-r, 2) };
    }
    const denom = (max - min) || 1;
    let zeroPct = ((max - 0) / denom) * 100;
    zeroPct = clamp(zeroPct, 0, 100);
    return { min, max, zeroPct, topLabel: fmtNum(max, 3), midLabel: '0', botLabel: fmtNum(min, 3) };
  })();

  const axisHtml = `
    <div class="rapm-axis">
      <div class="lbl top">${axis.topLabel}</div>
      <div class="lbl mid" style="top:${scale.mode === 'pct' ? axis.midPct : axis.zeroPct}%;">${axis.midLabel}</div>
      <div class="lbl bot">${axis.botLabel}</div>
    </div>
  `;

  const cols = bars.map(b => {
    const raw = Number(b.value);
    const ok = Number.isFinite(raw);
    const v = ok ? raw : 0;

    let topPct = 50;
    let heightPct = 0;
    let neg = false;
    let color = '#4da3ff';

    if(scale.mode === 'pct'){
      const p = clamp(v, 0, 100);
      topPct = 100 - p;
      heightPct = p;
      color = percentileToColor(p);
    }else{
      const min = axis.min;
      const max = axis.max;
      const denom = (max - min) || 1;
      const y = (val)=> ((max - val) / denom) * 100;
      const z0 = axis.zeroPct;
      const yv = y(v);
      topPct = Math.min(yv, z0);
      heightPct = Math.abs(yv - z0);
      neg = v < 0;
      color = neg ? '#ff6a6a' : '#4da3ff';
    }

    const label = ok ? (scale.mode === 'pct' ? `${fmtNum(v, 1)}%` : fmtNum(v, 3)) : '';

    return `
      <div class="bar-col">
        <div class="bar-area">
          ${scale.mode === 'pct'
            ? `<div class="bar-line" style="top:${axis.midPct}%;"></div>`
            : `<div class="bar-line" style="top:${axis.zeroPct}%;"></div>`
          }
          <div class="bar ${neg ? 'neg' : ''}" style="top:${topPct}%; height:${heightPct}%; background:${color};"></div>
        </div>
        <div class="bar-label">${b.label}</div>
        <div class="bar-value">${label}</div>
      </div>
    `;
  }).join('');

  return `
    <div class="rapm-sect">
      <h3>${title}</h3>
      <div class="rapm-row">${axisHtml}<div class="bars">${cols}</div></div>
      <div class="toi" data-toi="${title}"></div>
    </div>
  `;
}

function renderNotEnoughSection(title, minsStr, threshold){
  return `
    <div class="rapm-sect">
      <h3>${title}</h3>
      <div class="skater-empty" style="padding:18px 8px;">Not enough data</div>
      <div class="toi">${minsStr ? `TOI: ${minsStr} min` : 'TOI: -'}${threshold ? ` (min ${threshold})` : ''}</div>
    </div>
  `;
}

function renderRAPMUI(){
  if(!rapmPanelInner) return;
  rapmPanelInner.className = '';
  rapmPanelInner.innerHTML = `
    <div class="rapm-controls">
      <label>Period
        <select id="rapmPeriod">
          <option value="season">Season</option>
          <option value="career">Career</option>
        </select>
      </label>
      <label id="rapmCareerStrengthWrap" style="display:none;">Strength
        <select id="rapmCareerStrength">
          <option value="All">All</option>
          <option value="5v5">5v5</option>
          <option value="PP">PP</option>
          <option value="SH">SH</option>
        </select>
      </label>
      <label>Metric
        <select id="rapmMetric">
          <option value="corsi">Corsi</option>
          <option value="xg">xG</option>
          <option value="goals">Goals</option>
        </select>
      </label>
      <label>Rates/Totals
        <select id="rapmRatesTotals">
          <option value="Rates">Rates</option>
          <option value="Totals">Totals</option>
        </select>
      </label>
      <label>Output
        <select id="rapmOutput">
          <option value="value">Value</option>
          <option value="pct">Percentile</option>
          <option value="z">Z-Score</option>
        </select>
      </label>
      <label id="rapmRangeWrap" style="display:none;">Range
        <select id="rapmZRange">
          <option value="1">±1</option>
          <option value="2" selected>±2</option>
          <option value="3">±3</option>
          <option value="4">±4</option>
          <option value="5">±5</option>
        </select>
      </label>
    </div>
    <div id="rapmChart"></div>
    <div id="rapmCareer" class="rapm-career" style="display:none;"></div>
  `;

  const periodSel = document.getElementById('rapmPeriod');
  const careerStrengthWrap = document.getElementById('rapmCareerStrengthWrap');
  const careerStrengthSel = document.getElementById('rapmCareerStrength');
  const metricSel = document.getElementById('rapmMetric');
  const rtSel = document.getElementById('rapmRatesTotals');
  const outSel = document.getElementById('rapmOutput');
  const rangeWrap = document.getElementById('rapmRangeWrap');
  const rangeSel = document.getElementById('rapmZRange');

  function prefKey(k){ return `skaters_rapm_${k}`; }
  function loadPrefs(){
    try{
      const p = localStorage.getItem(prefKey('period'));
      const cs = localStorage.getItem(prefKey('careerStrength'));
      const m = localStorage.getItem(prefKey('metric'));
      const rt = localStorage.getItem(prefKey('ratesTotals'));
      const o = localStorage.getItem(prefKey('output'));
      const zr = localStorage.getItem(prefKey('zRange'));
      if(p && periodSel && Array.from(periodSel.options).some(x=>x.value===p)) periodSel.value = p;
      if(cs && careerStrengthSel && Array.from(careerStrengthSel.options).some(x=>x.value===cs)) careerStrengthSel.value = cs;
      if(m && metricSel && Array.from(metricSel.options).some(x=>x.value===m)) metricSel.value = m;
      if(rt && rtSel && Array.from(rtSel.options).some(x=>x.value===rt)) rtSel.value = rt;
      if(o && outSel && Array.from(outSel.options).some(x=>x.value===o)) outSel.value = o;
      if(zr && rangeSel && Array.from(rangeSel.options).some(x=>x.value===zr)) rangeSel.value = zr;
    }catch(e){/* ignore */}
  }
  function savePrefs(){
    try{
      if(periodSel) localStorage.setItem(prefKey('period'), String(periodSel.value||''));
      if(careerStrengthSel) localStorage.setItem(prefKey('careerStrength'), String(careerStrengthSel.value||''));
      if(metricSel) localStorage.setItem(prefKey('metric'), String(metricSel.value||''));
      if(rtSel) localStorage.setItem(prefKey('ratesTotals'), String(rtSel.value||''));
      if(outSel) localStorage.setItem(prefKey('output'), String(outSel.value||''));
      if(rangeSel) localStorage.setItem(prefKey('zRange'), String(rangeSel.value||''));
    }catch(e){/* ignore */}
  }

  loadPrefs();
  applyRAPMSelectTextColor();

  function update(){
    savePrefs();
    if(!__rapmCache) return;
    const rows = Array.isArray(__rapmCache?.rows) ? __rapmCache.rows : [];
    const ctxRows = Array.isArray(__ctxCache?.rows) ? __ctxCache.rows : [];
    if(!rows.length){
      const chart = document.getElementById('rapmChart');
      if(chart) chart.innerHTML = '<div class="skater-empty">No RAPM data.</div>';
      return;
    }

    const output = String(outSel?.value || 'value');
    const mode = output === 'pct' ? 'pct' : (output === 'z' ? 'z' : 'value');
    const zRange = parseLocaleNumber(rangeSel?.value || '2');
    if(rangeWrap) rangeWrap.style.display = (output === 'z') ? '' : 'none';

    const period = String(periodSel?.value || 'season');
    const chart = document.getElementById('rapmChart');
    const career = document.getElementById('rapmCareer');
    if(careerStrengthWrap) careerStrengthWrap.style.display = (period === 'career') ? '' : 'none';
    if(chart) chart.style.display = (period === 'career') ? 'none' : '';
    if(career) career.style.display = (period === 'career') ? '' : 'none';
    applyRAPMSelectTextColor();

    if(period === 'career'){
      renderRAPMCareer({
        playerId: String(playerSelect?.value || ''),
        ratesTotals: String(rtSel?.value || 'Rates'),
        metric: String(metricSel?.value || 'corsi'),
        output,
        zRange,
        strength: String(careerStrengthSel?.value || '5v5'),
      });
      return;
    }

    const opts = {
      metric: String(metricSel?.value || 'corsi'),
      ratesTotals: String(rtSel?.value || 'Rates'),
      output: output,
      zRange: zRange,
    };
    const row5 = pickStrengthRow(rows, '5v5', opts.ratesTotals) || pickRow(rows, opts.ratesTotals);
    const rowPP = pickStrengthRow(rows, 'PP', opts.ratesTotals) || row5;
    const rowSH = pickStrengthRow(rows, 'SH', opts.ratesTotals) || row5;
    const mins5 = parseLocaleNumber(pickCtxRow(ctxRows, '5v5')?.Minutes);
    const minsp = parseLocaleNumber(pickCtxRow(ctxRows, 'PP')?.Minutes);
    const minss = parseLocaleNumber(pickCtxRow(ctxRows, 'SH')?.Minutes);
    const elig5 = Number.isFinite(mins5) && mins5 >= 100;
    const eligp = Number.isFinite(minsp) && minsp >= 40;
    const eligs = Number.isFinite(minss) && minss >= 40;

    if(!chart) return;

    if(!elig5 && !eligp && !eligs){
      chart.innerHTML = '<div class="skater-empty">Not enough data.</div>';
      return;
    }

    const season = String(seasonSelect?.value || '');
    const scaleKey = `${season}|${opts.ratesTotals}|${opts.metric}`;
    if(mode === 'value' || mode === 'pct'){
      if(__scaleKey !== scaleKey){ __scaleKey = scaleKey; __scaleCache = null; }
    }

    const renderWithScale = (scale)=>{
      const thresholds = scale?.thresholds || { fivev5: 100, pp: 40, sh: 40 };
      const playerPct = scale?.player?.percentiles || null;
      const bars = buildBarsFromRows(row5, rowPP, rowSH, { metric: opts.metric, output: output, percentiles: playerPct });

      const five = scale?.fivev5 || {};
      const pp = scale?.pp || {};
      const sh = scale?.sh || {};

      const mins5s = fmtNum(mins5, 1);
      const minsps = fmtNum(minsp, 1);
      const minsss = fmtNum(minss, 1);

      const sect5 = elig5
        ? renderBarSection('5v5', bars.fivev5, {mode, min: five.min, max: five.max, range: zRange})
        : renderNotEnoughSection('5v5', mins5s, thresholds.fivev5);
      const sectP = eligp
        ? renderBarSection('PP', bars.pp, {mode, min: pp.min, max: pp.max, range: zRange})
        : renderNotEnoughSection('PP', minsps, thresholds.pp);
      const sectS = eligs
        ? renderBarSection('SH', bars.sh, {mode, min: sh.min, max: sh.max, range: zRange})
        : renderNotEnoughSection('SH', minsss, thresholds.sh);

      chart.innerHTML = `<div class="rapm-split">${sect5}${sectP}${sectS}</div>`;

      // Fill TOI labels for eligible sections
      try{
        const map = {
          '5v5': mins5s ? `TOI: ${mins5s} min` : 'TOI: -',
          'PP':  minsps ? `TOI: ${minsps} min` : 'TOI: -',
          'SH':  minsss ? `TOI: ${minsss} min` : 'TOI: -',
        };
        chart.querySelectorAll('.toi[data-toi]').forEach(el=>{
          const k = String(el.getAttribute('data-toi') || '').trim();
          if(map[k]) el.textContent = map[k];
        });
      }catch(e){ /* ignore */ }
    };

    if(mode === 'value' || mode === 'pct'){
      if(!__scaleCache){
        chart.innerHTML = '<div class="skater-empty">Loading scale...</div>';
        const pid = String(playerSelect?.value || '');
        const pidQ = pid ? `&playerId=${encodeURIComponent(pid)}` : '';
        fetch(`/api/rapm/scale?season=${encodeURIComponent(season)}&rates=${encodeURIComponent(opts.ratesTotals)}&metric=${encodeURIComponent(opts.metric)}${pidQ}`)
          .then(r=>r.json())
          .then(j=>{ __scaleCache = j; renderWithScale(j); })
          .catch(()=>{ __scaleCache = {}; renderWithScale({}); });
        return;
      }
      renderWithScale(__scaleCache);
      return;
    }

    if(mode === 'pct'){
      renderWithScale({ fivev5:{min:0,max:100}, pp:{min:0,max:100}, sh:{min:0,max:100} });
      return;
    }

    renderWithScale({ fivev5:{min:-zRange,max:zRange}, pp:{min:-zRange,max:zRange}, sh:{min:-zRange,max:zRange} });
    return;
  }

  periodSel?.addEventListener('change', update);
  careerStrengthSel?.addEventListener('change', update);
  metricSel?.addEventListener('change', update);
  rtSel?.addEventListener('change', update);
  outSel?.addEventListener('change', update);
  rangeSel?.addEventListener('change', update);
  update();
}

async function renderRAPMCareer(opts){
  const wrap = document.getElementById('rapmCareer');
  if(!wrap) return;
  wrap.innerHTML = '<div class="skater-empty">Loading career RAPM...</div>';

  const playerId = String(opts?.playerId || '').trim();
  if(!playerId){
    wrap.innerHTML = '<div class="skater-empty">Select a player to view RAPM.</div>';
    return;
  }

  const metric = String(opts?.metric || 'corsi');
  const ratesTotals = String(opts?.ratesTotals || 'Rates');
  const output = String(opts?.output || 'value');
  const mode = output === 'pct' ? 'pct' : (output === 'z' ? 'z' : 'value');
  const zRange = parseLocaleNumber(opts?.zRange || 2);
  const strength = String(opts?.strength || '5v5');

  try{
    const url = `/api/rapm/career?playerId=${encodeURIComponent(playerId)}&rates=${encodeURIComponent(ratesTotals)}&metric=${encodeURIComponent(metric)}&strength=${encodeURIComponent(strength)}`;
    const r = await fetch(url, { cache: 'no-store' });
    const data = await r.json();
    const points = Array.isArray(data?.points) ? data.points.slice() : [];
    points.sort((a,b)=>parseInt(a?.Season||0,10) - parseInt(b?.Season||0,10));

    const title = strength === '5v5' ? '5v5' : (strength === 'PP' ? 'PP' : 'SH');
    const isAll = (strength === 'All');
    const panelTitle = isAll ? 'ALL' : title;

    function num(x){
      const n = parseLocaleNumber(x);
      return Number.isFinite(n) ? n : null;
    }
    function fmtSigned(x){
      const n = num(x);
      if(n == null) return '';
      const s = (n > 0) ? '+' : '';
      return s + n.toFixed(3);
    }
    function pickValue(p, key){
      if(isAll){
        if(mode === 'pct') return num(p?.all_total_pct);
        if(mode === 'z') return num(p?.all_total_z);
        return num(p?.all_total);
      }
      if(title === 'PP'){
        if(mode === 'pct') return num(p?.pp_off_pct);
        if(mode === 'z') return num(p?.pp_off_z);
        return num(p?.pp_off);
      }
      if(title === 'SH'){
        if(mode === 'pct') return num(p?.sh_def_pct);
        if(mode === 'z') return num(p?.sh_def_z);
        return num(p?.sh_def);
      }
      // 5v5
      const base = (key === 'total') ? '5v5_total' : `5v5_${key}`;
      if(mode === 'pct') return num(p?.[`${base}_pct`]);
      if(mode === 'z') return num(p?.[`${base}_z`]);
      return num(p?.[base]);
    }

    // y-scale
    let yMin = null;
    let yMax = null;
    if(mode === 'pct'){
      yMin = 0; yMax = 100;
    }else if(mode === 'z'){
      yMin = -zRange; yMax = zRange;
    }else{
      yMin = num(data?.scale?.min);
      yMax = num(data?.scale?.max);
      if(yMin == null || yMax == null || yMin === yMax){
        const vals = [];
        for(const p of points){
          if(isAll){
            const v = pickValue(p,'total'); if(v != null) vals.push(v);
          }else if(title === '5v5'){
            ['off','def','total'].forEach(k=>{ const v = pickValue(p,k); if(v != null) vals.push(v); });
          }else if(title === 'PP'){
            const v = pickValue(p,'off'); if(v != null) vals.push(v);
          }else{
            const v = pickValue(p,'def'); if(v != null) vals.push(v);
          }
        }
        if(vals.length){ yMin = Math.min(...vals); yMax = Math.max(...vals); }
        else { yMin = -1; yMax = 1; }
        if(yMin === yMax){ yMin -= 1; yMax += 1; }
      }
    }

    const w = 820;
    const h = 420;
    const padL = 12;
    const padR = 12;
    const padT = 12;
    const padB = 34;
    const edgePad = 26;
    const plotW = w - padL - padR;
    const plotH = h - padT - padB;
    const n = Math.max(points.length, 2);
    const xAt = (i)=> {
      const denom = (n - 1) || 1;
      const innerW = Math.max(0, plotW - (edgePad * 2));
      return padL + edgePad + (innerW * i / denom);
    };
    const yAt = (v)=>{
      const t = (v - yMin) / (yMax - yMin);
      return padT + (plotH * (1 - t));
    };

    // axis labels (same layout as bars)
    const axisMax = (mode === 'pct') ? '100' : (mode === 'z') ? `+${zRange.toFixed(1)}` : fmtSigned(yMax);
    const axisMid = (mode === 'pct') ? '50' : '0';
    const axisMin = (mode === 'pct') ? '0' : (mode === 'z') ? `-${zRange.toFixed(1)}` : fmtSigned(yMin);
    const axisHtml = `
      <div class="rapm-axis">
        <div class="lbl top">${axisMax}</div>
        <div class="lbl mid" style="top:50%;">${axisMid}</div>
        <div class="lbl bot">${axisMin}</div>
      </div>`;

    function buildSegments(getVal){
      const segs = [];
      let cur = [];
      for(let i=0;i<points.length;i++){
        const v = getVal(points[i]);
        if(v == null){
          if(cur.length >= 2) segs.push(cur);
          cur = [];
          continue;
        }
        cur.push({x:xAt(i), y:yAt(v)});
      }
      if(cur.length >= 2) segs.push(cur);
      return segs;
    }

    const svgs = [];
    const midY = yAt(0);
    svgs.push(`<line x1="${padL}" y1="${midY.toFixed(2)}" x2="${(w-padR)}" y2="${midY.toFixed(2)}" stroke="rgba(255,255,255,0.18)" stroke-width="1" />`);

    const lines = (isAll)
      ? [{key:'total', color:'rgba(255,255,255,0.92)'}]
      : (title === '5v5')
        ? [
            {key:'off', color:'#2f6bff'},
            {key:'def', color:'#ff3b30'},
            {key:'total', color:'rgba(255,255,255,0.92)'}
          ]
        : (title === 'PP')
          ? [{key:'off', color:'#2f6bff'}]
          : [{key:'def', color:'#ff3b30'}];

    const lineLabel = (lnKey)=>{
      if(isAll) return 'Total';
      if(title === 'PP') return 'Off';
      if(title === 'SH') return 'Def';
      if(lnKey === 'off') return 'Off';
      if(lnKey === 'def') return 'Def';
      return 'Total';
    };

    const fmtTooltipVal = (v)=>{
      if(v == null) return '—';
      if(mode === 'pct') return `${v.toFixed(0)}%`;
      if(mode === 'z'){
        const s = (v > 0) ? '+' : '';
        return s + v.toFixed(2);
      }
      return fmtSigned(v);
    };

    let any = false;
    for(const ln of lines){
      const segs = buildSegments(p=>pickValue(p, ln.key));
      for(const seg of segs){
        any = true;
        const pts = seg.map(pt=>`${pt.x.toFixed(2)},${pt.y.toFixed(2)}`).join(' ');
        svgs.push(`<polyline fill="none" stroke="${ln.color}" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" points="${pts}" />`);
      }
      for(let i=0;i<points.length;i++){
        const v = pickValue(points[i], ln.key);
        if(v == null) continue;
        any = true;
        svgs.push(`<circle cx="${xAt(i).toFixed(2)}" cy="${yAt(v).toFixed(2)}" r="3" fill="${ln.color}" />`);
      }
    }

    const ticks = [];
    for(let i=0;i<points.length;i++){
      const s = formatSeasonShort(points[i]?.Season);
      if(!s) continue;
      const show = (i === 0) || (i === points.length - 1) || (i % 2 === 0);
      if(!show) continue;
      ticks.push(`<text x="${xAt(i).toFixed(2)}" y="${(h-10)}" text-anchor="middle" fill="rgba(255,255,255,0.7)" font-size="14">${s}</text>`);
    }

    const plot = any
      ? `<div class="bar-area career-area"><svg viewBox="0 0 ${w} ${h}" preserveAspectRatio="none">${svgs.join('')}${ticks.join('')}</svg></div>`
      : `<div class="skater-empty" style="padding:18px 8px;">Not enough data</div>`;

    wrap.innerHTML = `
      <div class="rapm-sect" style="--rapmBarH: 420px;">
        <h3>${panelTitle}</h3>
        <div class="rapm-row">${axisHtml}${plot}</div>
        ${(!isAll && title === '5v5') ? `
          <div class="rapm-career-legend">
            <span><span class="sw" style="background:#2f6bff"></span>Off</span>
            <span><span class="sw" style="background:#ff3b30"></span>Def</span>
            <span><span class="sw" style="background:rgba(255,255,255,0.92)"></span>Total</span>
          </div>` : ''}
      </div>
    `;

    // Tooltip
    try{
      const area = wrap.querySelector('.career-area');
      const svg = wrap.querySelector('.career-area svg');
      if(area && svg && points.length){
        area.style.position = 'relative';
        let tip = wrap.querySelector('.rapm-tooltip');
        if(!tip){
          tip = document.createElement('div');
          tip.className = 'rapm-tooltip';
          area.appendChild(tip);
        }

        const seasons = points.map(p=>formatSeasonShort(p?.Season));
        const series = lines.map(ln=>({
          key: ln.key,
          label: lineLabel(ln.key),
          color: ln.color,
          values: points.map(p=>pickValue(p, ln.key)),
        }));

        const nearestIndex = (xPx)=>{
          const rect = svg.getBoundingClientRect();
          const t = (xPx - rect.left) / Math.max(1, rect.width);
          const xSvg = t * w;
          let bestI = 0;
          let bestD = Infinity;
          for(let i=0;i<points.length;i++){
            const d = Math.abs(xAt(i) - xSvg);
            if(d < bestD){ bestD = d; bestI = i; }
          }
          return bestI;
        };

        const renderTip = (i)=>{
          const title = seasons[i] || '';
          const rows = [];
          for(const s of series){
            const v = s.values[i];
            if(v == null) continue;
            rows.push(`<div class="t-row"><span class="lbl"><span class="dot" style="background:${s.color}"></span>${s.label}</span><span class="val">${fmtTooltipVal(v)}</span></div>`);
          }
          tip.innerHTML = `<div class="t-title">${title}</div>${rows.join('')}`;
        };

        const moveTip = (evt)=>{
          const rect = svg.getBoundingClientRect();
          const i = nearestIndex(evt.clientX);
          renderTip(i);
          tip.style.display = 'block';
          const x = evt.clientX - rect.left;
          const y = evt.clientY - rect.top;
          const pad = 12;
          // place to the right/up when possible
          const areaRect = area.getBoundingClientRect();
          const maxX = areaRect.width;
          const maxY = areaRect.height;
          // measure after content
          const tw = tip.offsetWidth || 180;
          const th = tip.offsetHeight || 80;
          let left = x + 14;
          let top = y - th - 14;
          if(left + tw + pad > maxX) left = x - tw - 14;
          if(top < pad) top = y + 14;
          left = Math.max(pad, Math.min(maxX - tw - pad, left));
          top = Math.max(pad, Math.min(maxY - th - pad, top));
          tip.style.left = `${left}px`;
          tip.style.top = `${top}px`;
        };

        const hideTip = ()=>{ tip.style.display = 'none'; };
        area.addEventListener('mousemove', moveTip);
        area.addEventListener('mouseleave', hideTip);
        area.addEventListener('touchstart', (e)=>{
          if(!e.touches || !e.touches[0]) return;
          moveTip(e.touches[0]);
        }, {passive:true});
        area.addEventListener('touchmove', (e)=>{
          if(!e.touches || !e.touches[0]) return;
          moveTip(e.touches[0]);
        }, {passive:true});
        area.addEventListener('touchend', hideTip);
      }
    }catch(_){ /* ignore tooltip failures */ }
  }catch(e){
    wrap.innerHTML = '<div class="skater-empty">Error loading career RAPM.</div>';
  }
}

function formatSeasonShort(seasonVal){
  const n = parseInt(String(seasonVal || '').replace(/\D/g,''), 10);
  if(!Number.isFinite(n)) return '';
  const start = Math.floor(n / 10000);
  const end = n % 10000;
  if(!start || !end) return '';
  const a = String(start).slice(-2);
  const b = String(end).slice(-2);
  return `${a}/${b}`;
}

function fmtNum(x, digits=3){
  const n = parseLocaleNumber(x);
  if(!Number.isFinite(n)) return '';
  return n.toFixed(digits);
}

async function loadRAPMPanel(){
  if(!rapmPanelInner) return;
  const playerId = playerSelect?.value;
  const season = seasonSelect?.value;
  if(!playerId){
    rapmPanelInner.textContent = 'Select a player to view RAPM.';
    return;
  }
  rapmPanelInner.textContent = 'Loading RAPM...';
  try{
    const key = `${playerId}|${season||''}`;
    if(__rapmKey !== key){
      __rapmKey = key;
      __rapmCache = null;
      __ctxCache = null;
    }

    if(!__rapmCache || !__ctxCache){
      const rapmUrl = `/api/rapm/player/${encodeURIComponent(playerId)}?season=${encodeURIComponent(season||'')}`;
      const ctxUrl = `/api/context/player/${encodeURIComponent(playerId)}?season=${encodeURIComponent(season||'')}`;
      const [rapmRes, ctxRes] = await Promise.all([fetch(rapmUrl), fetch(ctxUrl)]);
      __rapmCache = await rapmRes.json();
      __ctxCache = await ctxRes.json();
    }

    renderRAPMUI();
  }catch(e){
    rapmPanelInner.textContent = 'Error loading RAPM.';
  }
}

async function loadProjectionsPanel(){
  if(!projPanelInner) return;
  if(!projectionsEnabled()){
    projPanelInner.textContent = '';
    return;
  }
  const playerId = playerSelect?.value;
  const teamAbbrev = String(teamSelect?.value||'').toUpperCase();
  const season = seasonSelect?.value;
  try{
    const league = await ensureProjLeaguePlayers();
    
    // Fetch context data for all league players
    const contextPromises = league.map(async (p)=>{
      try{
        const r = await fetch(`/api/context/player/${encodeURIComponent(p.playerId)}?season=${encodeURIComponent(season||'')}`, { cache:'no-store' });
        const data = await r.json();
        if(!data?.error && Array.isArray(data.rows)){
          // Find the 5v5 row
          const row5v5 = data.rows.find(row => String(row.StrengthState||'') === '5v5');
          if(row5v5){
            const parseNum = (val) => {
              if(val == null) return null;
              // If already a number, return it
              if(typeof val === 'number') return Number.isFinite(val) ? val : null;
              // Parse string values
              const n = parseLocaleNumber(val);
              return Number.isFinite(n) ? n : null;
            };
            p.contextData = { 
              QoT: parseNum(row5v5.QoT_blend_xG67_G33), 
              QoC: parseNum(row5v5.QoC_blend_xG67_G33), 
              ZS: parseNum(row5v5.ZS_Difficulty) 
            };
          }
        }
      }catch(_){ /* ignore context fetch failures */ }
    });
    await Promise.all(contextPromises);

    const teamObj = teams.find(tm=>String(tm?.Team||tm?.team||'').toUpperCase() === teamAbbrev);
    const teamColor = teamObj?.Color || teamObj?.color || null;

    // Set CSS variable for team color highlight
    if(teamColor){
      const rgb = hexToRgb(teamColor);
      if(rgb){
        document.documentElement.style.setProperty('--league-highlight-color', `rgba(${rgb.r},${rgb.g},${rgb.b},0.15)`);
      }
    }

    renderLeagueTable(league, playerId);

    const p = league.find(x=>String(x.playerId) === String(playerId||''));
    const playerContext = p?.contextData || null;
    renderPlayerKpisFromLeague(p, playerContext);
    renderPlayerRadarFromLeague(p, league, playerContext, teamColor);

    renderTeamStackFromLeague(teamAbbrev, league, teamColor);
  }catch(e){
    if(projPlayerKpis) projPlayerKpis.innerHTML = '<div class="skater-empty" style="grid-column:1 / -1; padding:8px 2px;">Error loading projections.</div>';
  }
}

async function loadPlayers(){
  if(!teamSelect || !seasonSelect || !playerSelect) return;
  const team = teamSelect.value;
  const season = seasonSelect.value;
  const seasonState = String(cardSeasonState?.value || 'regular');
  if(!team || !season){
    playerSelect.innerHTML = '<option value="">Select team/season</option>';
    return;
  }
  playerSelect.disabled = true;
  playerSelect.innerHTML = '<option value="">Loading...</option>';
  try{
    const r = await fetch(`/api/skaters/players?team=${encodeURIComponent(team)}&season=${encodeURIComponent(season)}&seasonState=${encodeURIComponent(seasonState)}`);
    const data = await r.json();
    const list = Array.isArray(data?.players) ? data.players : [];
    list.sort((a,b)=> String(a.name||'').localeCompare(String(b.name||'')));
    const savedKey = `skaters_player_${team}`;
    const saved = localStorage.getItem(savedKey);
    playerSelect.innerHTML = '<option value="">Select player</option>' + list.map(p=>`<option value="${p.playerId}">${p.name}</option>`).join('');
    if(__restorePlayerId && list.some(p=>String(p.playerId)===String(__restorePlayerId))){
      playerSelect.value = String(__restorePlayerId);
      __restorePlayerId = null;
    }else if(saved && list.some(p=>String(p.playerId)===saved)){
      playerSelect.value = saved;
    }
  }catch(e){
    playerSelect.innerHTML = '<option value="">Error loading players</option>';
  }finally{
    playerSelect.disabled = false;
  }
}

async function loadPlayerCard(){
  if(!teamSelect || !seasonSelect || !playerSelect) return;
  const team = teamSelect.value;
  const season = seasonSelect.value;
  const playerId = playerSelect.value;
  if(!playerId){
    setDefaultHeadshot();
    skaterName.textContent = 'Select a player';
    skaterInfo.innerHTML = '';
    setMsg('Choose Team, Season, and Player.');
    return;
  }
  localStorage.setItem(`skaters_player_${team}`, String(playerId));
  setHeadshot(team, season, playerId);
  setMsg('Loading player info...');
  try{
    const r = await fetch(`/api/player/${encodeURIComponent(playerId)}/landing`);
    const data = await r.json();
    if(data?.error){
      setMsg('Could not load player info.', true);
      skaterInfo.innerHTML = '';
      skaterName.textContent = 'Unknown player';
      setDefaultHeadshot();
      return;
    }
    renderPlayerLanding(data);
    setMsg('');
    if(cardEnabled()) loadCardPanel();
    loadRAPMPanel();
    if(projectionsEnabled()) loadProjectionsPanel();
  }catch(e){
    setMsg('Could not load player info.', true);
    setDefaultHeadshot();
  }
}

tabCard?.addEventListener('click', ()=> setActiveTab('card'));
tabTable?.addEventListener('click', ()=> setActiveTab('table'));
tabCharts?.addEventListener('click', ()=> setActiveTab('charts'));
  // Charts interactions
  try{ pdX?.addEventListener('change', ()=> { renderCharts(); saveSkatersState(); }); }catch(_){/*noop*/}
  try{ pdY?.addEventListener('change', ()=> { renderCharts(); saveSkatersState(); }); }catch(_){/*noop*/}
  try{ scX?.addEventListener('change', ()=> { renderCharts(); saveSkatersState(); }); }catch(_){/*noop*/}
  try{ scY?.addEventListener('change', ()=> { renderCharts(); saveSkatersState(); }); }catch(_){/*noop*/}
  // Re-render charts when shared slicers change.
  try{ seasonSelect?.addEventListener('change', ()=> { if(!tabCharts?.classList.contains('active')) return; __chartsLastKey=''; renderCharts(); }); }catch(_){/*noop*/}
  try{ teamSelect?.addEventListener('change', ()=> { if(!tabCharts?.classList.contains('active')) return; __chartsLastKey=''; renderCharts(); }); }catch(_){/*noop*/}
  try{ playerSelect?.addEventListener('change', ()=> { try{ __pdChart && __pdChart.update('none'); }catch(_){/*noop*/} try{ __scChart && __scChart.update('none'); }catch(_){/*noop*/} }); }catch(_){/*noop*/}
  try{ cardSeasonState?.addEventListener('change', ()=> { if(!tabCharts?.classList.contains('active')) return; __chartsLastKey=''; renderCharts(); }); }catch(_){/*noop*/}
  try{ cardStrengthState?.addEventListener('change', ()=> { if(!tabCharts?.classList.contains('active')) return; __chartsLastKey=''; renderCharts(); }); }catch(_){/*noop*/}
  try{ cardRates?.addEventListener('change', ()=> { if(!tabCharts?.classList.contains('active')) return; __chartsLastKey=''; refreshChartMetricLabels(); renderCharts(); }); }catch(_){/*noop*/}
  try{ cardXgModel?.addEventListener('change', ()=> { if(!tabCharts?.classList.contains('active')) return; __chartsLastKey=''; refreshChartMetricLabels(); renderCharts(); }); }catch(_){/*noop*/}
  try{ cardMinGp?.addEventListener('change', ()=> { if(!tabCharts?.classList.contains('active')) return; __chartsLastKey=''; renderCharts(); }); }catch(_){/*noop*/}
  try{ cardMinToi?.addEventListener('change', ()=> { if(!tabCharts?.classList.contains('active')) return; __chartsLastKey=''; renderCharts(); }); }catch(_){/*noop*/}
  // Scope segmented buttons already call loadCardPanel(); extend to re-render charts too.
  // (Keep behavior localized: just trigger charts refresh after scope changes.)
  // NOTE: setCardScope() itself doesn't call renderCharts.
tabEdge?.addEventListener('click', ()=> setActiveTab('edge'));
tabRAPM?.addEventListener('click', ()=> setActiveTab('rapm'));
tabProjections?.addEventListener('click', ()=> setActiveTab('projections'));

cardSeasonState?.addEventListener('change', ()=> loadCardPanel());
cardSeasonState?.addEventListener('change', async ()=>{
  // Player list depends on seasonState in /api/skaters/players
  await loadPlayers();
  await loadPlayerCard();
});
cardSeasonState?.addEventListener('change', ()=>{
  if(tabEdge?.classList.contains('active')) loadEdgePanel();
});
edgeSeasonState?.addEventListener('change', ()=>{
  if(tabEdge?.classList.contains('active')) loadEdgePanel();
  saveSkatersState();
});
cardMinGp?.addEventListener('change', ()=> loadCardPanel());
cardMinToi?.addEventListener('change', ()=> loadCardPanel());
cardStrengthState?.addEventListener('change', ()=> loadCardPanel());
cardRates?.addEventListener('change', ()=> loadCardPanel());
cardXgModel?.addEventListener('change', ()=> loadCardPanel());

function __maybeReloadTable(){
  if(isTableActive()){
    __tableLastKey = '';
    loadTablePanel();
  }
}
cardSeasonState?.addEventListener('change', __maybeReloadTable);
cardMinGp?.addEventListener('change', __maybeReloadTable);
cardMinToi?.addEventListener('change', __maybeReloadTable);
cardStrengthState?.addEventListener('change', __maybeReloadTable);
cardRates?.addEventListener('change', __maybeReloadTable);
cardXgModel?.addEventListener('change', __maybeReloadTable);
seasonSelect?.addEventListener('change', __maybeReloadTable);

btnReloadTable?.addEventListener('click', ()=>{ __tableLastKey=''; loadTablePanel(); });
btnConfigureTable?.addEventListener('click', async ()=>{ await showTableConfig(); });
btnExportTableCsv?.addEventListener('click', async ()=>{ await exportTableCsv(); });
btnCloseTableConfig?.addEventListener('click', ()=> closeTableConfig());
tableConfigModal?.addEventListener('click', (e)=>{ if(e?.target === tableConfigModal) closeTableConfig(); });
document.addEventListener('keydown', (e)=>{ if(e?.key === 'Escape' && tableConfigModal && !tableConfigModal.hidden) closeTableConfig(); });

cardSeasonState?.addEventListener('change', ()=> { updateCardSlicerSummary(); saveSkatersState(); });
cardMinGp?.addEventListener('change', ()=> { updateCardSlicerSummary(); saveSkatersState(); });
cardMinToi?.addEventListener('change', ()=> { updateCardSlicerSummary(); saveSkatersState(); });
cardStrengthState?.addEventListener('change', ()=> { updateCardSlicerSummary(); saveSkatersState(); });
cardRates?.addEventListener('change', ()=> { updateCardSlicerSummary(); saveSkatersState(); });
cardXgModel?.addEventListener('change', ()=> { updateCardSlicerSummary(); saveSkatersState(); });

// Min GP / Min TOI inputs only fire "change" on blur; persist while typing.
let __minFilterSaveTimer = null;
function __scheduleMinFilterSave(){
  try{ if(__minFilterSaveTimer) clearTimeout(__minFilterSaveTimer); }catch(_){/*noop*/}
  __minFilterSaveTimer = setTimeout(()=>{
    updateCardSlicerSummary();
    saveSkatersState();
    if(tabCharts?.classList.contains('active')){
      __chartsLastKey='';
      renderCharts();
    }
  }, 250);
}
try{ cardMinGp?.addEventListener('input', __scheduleMinFilterSave); }catch(_){/*noop*/}
try{ cardMinToi?.addEventListener('input', __scheduleMinFilterSave); }catch(_){/*noop*/}

btnConfigureCard?.addEventListener('click', async ()=>{
  await showCardConfig();
});
btnCloseCardConfig?.addEventListener('click', ()=> closeCardConfig());
cardConfigModal?.addEventListener('click', (e)=>{
  // click backdrop to close
  if(e?.target === cardConfigModal) closeCardConfig();
});
document.addEventListener('keydown', (e)=>{
  if(e?.key === 'Escape' && cardConfigModal && !cardConfigModal.hidden) closeCardConfig();
});
btnResetCardConfig?.addEventListener('click', async ()=>{
  const defs = await ensureCardDefs();
  __cardConfig = buildDefaultCardConfig(defs);
  renderCardConfigModal(defs, __cardConfig);
});
btnSaveCardConfig?.addEventListener('click', ()=>{
  if(__cardConfig){
    saveCardConfig(__cardConfig);
    closeCardConfig();
    loadCardPanel();
  }
});

btnExportCardConfig?.addEventListener('click', async ()=>{
  await exportCardConfig();
});

btnImportCardConfig?.addEventListener('click', async ()=>{
  // Prefer file import; if user cancels, fall back to paste.
  if(ccImportFile){
    try{ ccImportFile.value = ''; }catch(_){/*noop*/}
    ccImportFile.click();
    return;
  }
  const t = prompt('Paste card config JSON');
  if(t) await importCardConfigFromText(t);
});

ccImportFile?.addEventListener('change', async ()=>{
  const f = ccImportFile.files && ccImportFile.files[0];
  if(!f){
    const t = prompt('Paste card config JSON');
    if(t) await importCardConfigFromText(t);
    return;
  }
  try{
    const text = await f.text();
    await importCardConfigFromText(text);
  }catch(_){
    alert('Could not read file.');
  }
});

projTabPlayer?.addEventListener('click', ()=> { setActiveProjSubtab('player'); saveSkatersState(); });
projTabTeam?.addEventListener('click', ()=> { setActiveProjSubtab('team'); saveSkatersState(); });
projTabLeague?.addEventListener('click', ()=> { setActiveProjSubtab('league'); saveSkatersState(); });

projExportCsv?.addEventListener('click', ()=>{
  if(!__projLeaguePlayers || !__projLeaguePlayers.length) return;
  const cols = ['name','team','position','gp','Age','Rookie','EVO','EVD','PP','SH','QoT','QoC','ZS','total'];
  const header = cols.join(',');
  const rows = __projLeaguePlayers.filter(p=>p.name && String(p.name).trim()).map(p=>{
    return cols.map(c=>{
      if(c === 'QoT' || c === 'QoC' || c === 'ZS'){
        const v = p.contextData?.[c];
        return v != null ? String(v) : '';
      }
      const v = p[c];
      return v != null ? String(v) : '';
    }).join(',');
  });
  const csv = header + '\n' + rows.join('\n');
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = 'projections_league.csv';
  link.click();
});

teamSelect?.addEventListener('change', async ()=>{
  await loadPlayers();
  await loadPlayerCard();
  applyRAPMSelectTextColor();
  applyExportButtonTextColor();
  if(projectionsEnabled()) loadProjectionsPanel();
  updateCardSlicerSummary();
  saveSkatersState();
});
seasonSelect?.addEventListener('change', async ()=>{
  updateTabsVisibility();
  await loadPlayers();
  await loadPlayerCard();
  updateCardSlicerSummary();
  saveSkatersState();
});
playerSelect?.addEventListener('change', ()=> { loadPlayerCard(); saveSkatersState(); });

// Boot sequence: restore persisted state and load once base.html filters are ready.
initSkatersPage();
</script>
{% endblock %}
