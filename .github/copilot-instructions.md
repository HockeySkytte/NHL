# Copilot instructions (NHL)

## Big picture
- This is a **Flask** web app serving HTML pages + JSON APIs.
- Entrypoints:
  - `run.py` runs the dev server (`create_app()` + `debug=True`).
  - `wsgi.py` exposes `app` for production (`gunicorn ... wsgi:app`).
- The app is intentionally **logic-heavy in one module**: most API/data/model code lives in `app/routes.py` (single Flask `Blueprint`).

## Key folders / artifacts
- `app/routes.py`: primary HTTP API surface + caching + model loading.
- `app/templates/`: HTML pages (`index.html`, `live.html`, `standings.html`, `projections.html`, `game.html`).
- `app/static/`:
  - `lineups_all.json` (generated by `scripts/lineups.py` and used by projections helpers).
  - `player_projections.csv` (legacy fallback; projections are primarily loaded from Google Sheets tab `Sheets3`).
  - `zones.json` / rink assets.
- `Model/`: pre-trained xG / win-prob models loaded via `joblib` (`xgbs_*.pkl`, `xgb_*.pkl`, `xgb2_*.pkl`).
- Root CSVs like `Teams.csv`, `Last_date.csv` are treated as data inputs.

## Request/data flow conventions
- Pages are rendered by simple routes in `app/routes.py`:
  - `/` → `index.html`, `/live` → `live.html`, `/standings` → `standings.html`, `/projections` → `projections.html`, `/game/<id>` → `game.html`.
- Client pages typically fetch JSON from `/api/...` routes (also in `app/routes.py`).
- NHL upstream APIs are called directly with `requests` (e.g. `api-web.nhle.com/v1/...`), so changes must be tolerant of upstream shape changes.

## Performance/caching patterns (don’t break)
- `app/routes.py` uses **module-level caches** (e.g. `_PBP_CACHE`, `_SHIFTS_CACHE`, `_MODEL_CACHE`).
- Some endpoints also persist a small **on-disk cache** (Windows: `%TEMP%/nhl_cache`, Linux/Render: `/tmp/nhl_cache`), overrideable with `XG_CACHE_DIR`.
- `create_app()` preloads “common” models at startup by default; scripts disable this with `XG_PRELOAD=0`.

## Model loading conventions
- Models are loaded through `load_model_file(fname)` in `app/routes.py` and cached in `_MODEL_CACHE`.
- Startup preload (`preload_common_models()`) loads a “central window” around the current season.
- If you add/rename model files, keep the naming scheme (`{prefix}_{startSeason}_{endSeason}.pkl`) consistent or update preload logic.

## Developer workflows
- Install deps: `python -m pip install -r requirements.txt`
- Run locally (dev): `python run.py`
  - VS Code task: **Run Flask app** runs the above using `.venv\\Scripts\\python.exe`.
- Production (Render): `gunicorn --bind 0.0.0.0:$PORT wsgi:app` (see `Procfile`, `render.yaml`).

## Scripts & operational jobs (used in prod)
- `scripts/lineups.py` scrapes DailyFaceoff (HTML) and writes `app/static/lineups_all.json`.
  - Render cron runs it every 30 minutes (see `render.yaml`).
- `scripts/update_data.py` reuses **internal Flask routes** via `create_app().test_client()` to fetch/normalize data.
  - It sets `XG_PRELOAD=0` and controls xG computation via the PBP route query (`/api/game/<id>/play-by-play?xg=0|1`).
- Admin endpoints to trigger scripts asynchronously exist in `app/routes.py`:
  - `POST /admin/run-update-data`, `POST /admin/run-lineups`, and `GET /admin/job/<id>` for status.

## Environment/config you’ll see
- DB connectivity (admin check + some scripts) is driven by env vars when present:
  - `DATABASE_URL(_RO/_RW)` or `DB_HOST`, `DB_USER`, `DB_PASSWORD`, `DB_PORT`, `DB_NAME`.
- Optional toggles:
  - `XG_PRELOAD` (default `1` in app, set to `0` in scripts)
  - `FETCH_BIOS` (PBP enrichment; scripts often set to `1`)
  - `*_CACHE_TTL_SECONDS` (e.g. `PBP_CACHE_TTL_SECONDS`, `BOX_CACHE_TTL_SECONDS`)

## When editing
- Prefer changing shared parsing/model logic in `app/routes.py` so both the web app and `scripts/update_data.py` stay consistent.
- If writing files on Render, use `XG_CACHE_DIR`/`PRESTART_DIR` patterns (don’t assume repo is writable).
